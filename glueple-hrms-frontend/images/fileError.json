{"nm":"Comp 2","ddd":0,"h":512,"w":512,"meta":{"g":"@lottiefiles/toolkit-js 0.33.2"},"layers":[{"ty":4,"nm":"Layer 7","sr":1,"st":100,"op":350,"ip":100,"hd":false,"ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[144.484,123.124,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[380.979,348.408,0],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-0.583,14.967]],"o":[[0,0],[0.583,-14.967]],"v":[[66.657,-116.574],[73.138,-143.296]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-12.828,10.495]],"o":[[0,0],[12.828,-10.495]],"v":[[77.511,-111.034],[105.498,-140.188]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 3","ix":3,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[0,0]],"o":[[0,0],[0,0]],"v":[[84.451,-100.539],[113.078,-105.033]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tm","bm":0,"hd":false,"mn":"ADBE Vector Filter - Trim","nm":"Trim Paths 1","ix":4,"e":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":100},{"s":[100],"t":125}],"ix":2},"o":{"a":0,"k":0,"ix":3},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":125},{"s":[100],"t":150}],"ix":1},"m":1}],"ind":1},{"ty":4,"nm":"Layer 6","sr":1,"st":50,"op":300,"ip":50,"hd":false,"ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[144.484,123.124,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":0,"k":[380.979,348.408,0],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-0.583,14.967]],"o":[[0,0],[0.583,-14.967]],"v":[[66.657,-116.574],[73.138,-143.296]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-12.828,10.495]],"o":[[0,0],[12.828,-10.495]],"v":[[77.511,-111.034],[105.498,-140.188]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 3","ix":3,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[0,0]],"o":[[0,0],[0,0]],"v":[[84.451,-100.539],[113.078,-105.033]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tm","bm":0,"hd":false,"mn":"ADBE Vector Filter - Trim","nm":"Trim Paths 1","ix":4,"e":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":50},{"s":[100],"t":75}],"ix":2},"o":{"a":0,"k":0,"ix":3},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":75},{"s":[100],"t":100}],"ix":1},"m":1}],"ind":2},{"ty":4,"nm":"Layer 2","sr":1,"st":0,"op":250,"ip":0,"hd":false,"ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[184.998,140.149,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[447.029,406,0],"t":0,"ti":[17.137,0,0],"to":[0,17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,437.029,0],"t":9.375,"ti":[0,17.137,0],"to":[-17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[384.971,406,0],"t":18.75,"ti":[-17.137,0,0],"to":[0,-17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,374.971,0],"t":28.125,"ti":[0,-17.137,0],"to":[17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[447.029,406,0],"t":37.5,"ti":[17.137,0,0],"to":[0,17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,437.029,0],"t":46.875,"ti":[0,17.137,0],"to":[-17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[384.971,406,0],"t":56.25,"ti":[-17.137,0,0],"to":[0,-17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,374.971,0],"t":65.625,"ti":[0,-17.137,0],"to":[17.137,0,0]},{"s":[447.029,406,0],"t":75}],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[{"ty":5,"mn":"Pseudo/Duik Kleaner v3.2","nm":"ŝlosilo pli pura","ix":1,"en":1,"ef":[{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0001","nm":"Anticipation","ix":1,"v":{"a":0,"k":0,"ix":1}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0002","nm":"Smart Interpolation","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0003","nm":"Follow Through","ix":3,"v":{"a":0,"k":1,"ix":3}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0004","nm":"Anticipation","ix":4,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0005","nm":"Duration (s)","ix":5,"v":{"a":0,"k":0.3,"ix":5}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0006","nm":"Amplitude","ix":6,"v":{"a":0,"k":50,"ix":6}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0007","nm":"","ix":7,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0008","nm":"Interpolation","ix":8,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0009","nm":"Slow In","ix":9,"v":{"a":0,"k":60,"ix":9}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0010","nm":"Slow Out","ix":10,"v":{"a":0,"k":25,"ix":10}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0011","nm":"","ix":11,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0012","nm":"Follow Through","ix":12,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0013","nm":"Elasticity","ix":13,"v":{"a":0,"k":10,"ix":13}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0014","nm":"Elasticity random","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0015","nm":"Damping","ix":15,"v":{"a":0,"k":50,"ix":15}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0016","nm":"Damping random","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0017","nm":"Bounce","ix":17,"v":{"a":0,"k":0,"ix":17}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0018","nm":"","ix":18,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0019","nm":"Spatial Options","ix":19,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0020","nm":"Smart Interpolation","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0021","nm":"Mode","ix":21,"v":{"a":0,"k":1,"ix":21}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0022","nm":"Overlap (simulation)","ix":22,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0023","nm":"Overlap","ix":23,"v":{"a":0,"k":1,"ix":23}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0024","nm":"Delay (s)","ix":24,"v":{"a":0,"k":0.05,"ix":24}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0025","nm":"Overlap random","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0026","nm":"","ix":26,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0027","nm":"Soft Body (simulation)","ix":27,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0028","nm":"Soft Body","ix":28,"v":{"a":0,"k":1,"ix":28}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0029","nm":"Soft-Body Flexibility","ix":29,"v":{"a":0,"k":100,"ix":29}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0030","nm":"","ix":30,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0031","nm":"","ix":31,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0032","nm":"Precision","ix":32,"v":{"a":0,"k":1,"ix":32}}]},{"ty":5,"mn":"Pseudo/Duik Kleaner v3.2","nm":"ŝlosilo pli pura 2","ix":2,"en":1,"ef":[{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0001","nm":"Anticipation","ix":1,"v":{"a":0,"k":0,"ix":1}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0002","nm":"Smart Interpolation","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0003","nm":"Follow Through","ix":3,"v":{"a":0,"k":1,"ix":3}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0004","nm":"Anticipation","ix":4,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0005","nm":"Duration (s)","ix":5,"v":{"a":0,"k":0.3,"ix":5}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0006","nm":"Amplitude","ix":6,"v":{"a":0,"k":50,"ix":6}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0007","nm":"","ix":7,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0008","nm":"Interpolation","ix":8,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0009","nm":"Slow In","ix":9,"v":{"a":0,"k":60,"ix":9}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0010","nm":"Slow Out","ix":10,"v":{"a":0,"k":25,"ix":10}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0011","nm":"","ix":11,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0012","nm":"Follow Through","ix":12,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0013","nm":"Elasticity","ix":13,"v":{"a":0,"k":10,"ix":13}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0014","nm":"Elasticity random","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0015","nm":"Damping","ix":15,"v":{"a":0,"k":50,"ix":15}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0016","nm":"Damping random","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0017","nm":"Bounce","ix":17,"v":{"a":0,"k":0,"ix":17}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0018","nm":"","ix":18,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0019","nm":"Spatial Options","ix":19,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0020","nm":"Smart Interpolation","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0021","nm":"Mode","ix":21,"v":{"a":0,"k":1,"ix":21}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0022","nm":"Overlap (simulation)","ix":22,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0023","nm":"Overlap","ix":23,"v":{"a":0,"k":1,"ix":23}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0024","nm":"Delay (s)","ix":24,"v":{"a":0,"k":0.05,"ix":24}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0025","nm":"Overlap random","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0026","nm":"","ix":26,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0027","nm":"Soft Body (simulation)","ix":27,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0028","nm":"Soft Body","ix":28,"v":{"a":0,"k":1,"ix":28}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0029","nm":"Soft-Body Flexibility","ix":29,"v":{"a":0,"k":100,"ix":29}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0030","nm":"","ix":30,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0031","nm":"","ix":31,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0032","nm":"Precision","ix":32,"v":{"a":0,"k":1,"ix":32}}]}],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":3,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[12.766,-15.013],[18.84,-0.781],[11.573,13.451],[-4.868,19.459],[-18.742,8.508],[-0.449,0.199],[-9.553,-0.852],[-1.122,-0.284],[-7.295,-4.261],[-1.501,-0.824],[-3.353,-15.994]],"o":[[-12.766,15.013],[-18.84,0.781],[-12.176,-14.161],[4.882,-19.474],[0.449,-0.213],[9.273,-3.92],[1.178,0.1],[5.471,1.364],[1.501,0.852],[13.958,7.698],[3.675,17.797]],"v":[[81.137,7.938],[30.229,33.15],[-18.196,12.725],[-30.316,-41.363],[7.995,-87.284],[9.369,-87.895],[38.239,-92.512],[41.704,-92.085],[62.985,-84.855],[67.558,-82.455],[96.063,-45.227]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 2","ix":2,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[4.166,20.112],[15.754,8.707],[1.697,0.98],[6.186,1.548],[1.333,0.114],[10.479,-4.446],[0.519,-0.228],[5.513,-22.002],[-13.748,-16.022],[-21.281,0.88],[-14.435,16.974]],"o":[[-3.774,-18.067],[-1.697,-0.937],[-8.249,-4.801],[-1.249,-0.312],[-10.788,-0.952],[-0.519,0.227],[-21.182,9.616],[-5.513,21.988],[13.074,15.198],[21.295,-0.895],[14.421,-16.96]],"v":[[104.326,-47.244],[72.131,-89.316],[66.955,-92.029],[42.897,-100.196],[38.983,-100.679],[6.367,-95.451],[4.81,-94.77],[-38.481,-42.869],[-24.789,18.265],[29.935,41.346],[87.478,12.839]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0.2157,0.4157],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":2,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":12,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,0],[0.34,0.04],[1.64,0.03],[1.03,-1.43],[0.31,-0.33],[1.42,-1.18],[0,0],[-0.02,0.06],[-0.06,0.2],[-0.03,0.14],[-0.05,0.24],[-0.02,0.12],[-0.01,0.37],[0.03,0.34],[0.01,0.1],[0.06,0.23],[0,0],[3.45,1.27],[2.48,-0.23],[-0.04,0.05],[-0.06,0.08],[0,0],[-0.07,0.12],[-0.09,0.18],[-0.07,0.16],[-0.07,0.16],[-0.06,0.19],[-0.05,0.16],[-0.05,0.24],[-0.02,0.13],[-0.01,0.38],[0.02,0.27],[0.24,0.69],[0,0],[0.01,0],[3.01,1.12],[2.99,-0.51],[-0.15,0.02],[-0.21,0.55],[-4.8,1.14],[0.13,0.59],[0.6,-0.14],[4.6,-0.26],[1.28,1.67],[1.58,0.7],[3.87,-1.11],[4.29,-2.56],[1.21,0.81],[0.62,3.45],[0.01,0.12],[-1.73,0],[-0.66,0.1],[-2.94,2.87],[-1.21,2.02],[-0.02,0.13],[-2.06,0.82],[-0.93,0.4],[-2.84,0.58],[-5.42,-3.1],[-3.57,-2.6],[-2.19,-1.47],[-0.6,-0.38],[-5.11,-0.07]],"o":[[-0.34,-0.04],[-1.66,-0.19],[-2.34,-0.04],[-0.33,0.46],[-1.4,1.49],[0,0],[0.03,-0.07],[0.08,-0.2],[0.04,-0.13],[0.07,-0.22],[0.02,-0.12],[0.05,-0.36],[0.01,-0.35],[-0.01,-0.1],[-0.03,-0.24],[0,0],[-0.74,-3.22],[-2.07,-0.77],[0.03,-0.05],[0.06,-0.09],[0,0],[0.07,-0.12],[0.1,-0.18],[0.08,-0.16],[0.08,-0.16],[0.08,-0.19],[0.06,-0.16],[0.06,-0.22],[0.02,-0.13],[0.06,-0.37],[0.01,-0.28],[-0.06,-0.72],[0,-0.01],[0,0],[-0.98,-2.79],[-2.45,-0.91],[0.15,-0.02],[0.29,-0.49],[4.94,-0.24],[0.59,-0.13],[-0.15,-0.59],[-4.46,1.05],[0.15,-1.9],[-1.03,-1.35],[-2.99,-1.32],[-3.24,0.94],[-1.31,-0.55],[-3.49,-2.33],[-0.02,-0.11],[1.51,0.68],[0.66,0],[3.27,-0.54],[1.63,-1.59],[0.07,-0.12],[2.19,-0.4],[0.95,-0.38],[2.7,-1.15],[8.08,-1.65],[3.86,2.21],[2.09,1.53],[0.6,0.41],[4.85,3.11],[0,0]],"v":[[158.51,107.71],[157.49,107.6],[152.47,107.18],[147.89,110.35],[146.94,111.57],[142.59,115.59],[128.37,95.62],[128.44,95.42],[128.65,94.82],[128.77,94.41],[128.93,93.72],[129,93.37],[129.1,92.28],[129.06,91.24],[129.01,90.95],[128.89,90.24],[128.89,90.23],[122,82.83],[115.09,82.03],[115.2,81.87],[115.37,81.62],[115.73,81.05],[115.94,80.68],[116.23,80.15],[116.45,79.67],[116.67,79.18],[116.87,78.61],[117.03,78.14],[117.19,77.45],[117.27,77.06],[117.38,75.93],[117.36,75.11],[116.91,72.99],[116.91,72.98],[116.9,72.98],[110.43,66.65],[102.12,66.07],[102.56,65.99],[103.31,64.43],[117.97,62.4],[118.79,61.08],[117.46,60.27],[103.83,62.21],[102.07,56.67],[98.08,53.54],[87.44,53.22],[75.21,58.36],[71.4,56.35],[64.93,47.25],[64.89,46.9],[69.82,47.96],[71.81,47.8],[81.31,42.58],[85.59,37.13],[85.72,36.74],[92.09,34.8],[94.91,33.62],[103.25,30.7],[124.92,35.49],[136.04,42.99],[142.49,47.57],[144.29,48.76],[159.35,52.74]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 2","ix":2,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,-0.05],[0.02,-0.15],[0.02,-0.09],[0.04,-0.14],[0.04,-0.12],[0.04,-0.11],[0.06,-0.15],[0.05,-0.09],[0.11,-0.18],[0.04,-0.07],[0.13,-0.19],[0.05,-0.07],[0.11,-0.15],[0.35,-0.41],[0.1,-0.11],[0.39,-0.39],[0.17,-0.17],[0.37,-0.33],[0.17,-0.14],[0.45,-0.34],[0.11,-0.09],[0.05,-0.04],[-0.08,0.5],[-1.73,1.65],[-1.72,0.22]],"o":[[-0.01,0.15],[-0.02,0.1],[-0.02,0.13],[-0.03,0.12],[-0.04,0.11],[-0.06,0.15],[-0.05,0.09],[-0.08,0.18],[-0.04,0.07],[-0.12,0.19],[-0.05,0.07],[-0.1,0.15],[-0.29,0.38],[-0.1,0.11],[-0.37,0.4],[-0.16,0.17],[-0.36,0.34],[-0.17,0.15],[-0.44,0.36],[-0.11,0.08],[-0.05,0.04],[0.02,-0.56],[0.47,-2.74],[1.35,-1.28],[0,0.04]],"v":[[131.6,108.25],[131.55,108.7],[131.49,108.98],[131.4,109.38],[131.29,109.74],[131.17,110.07],[130.98,110.52],[130.85,110.78],[130.56,111.32],[130.45,111.52],[130.08,112.09],[129.94,112.3],[129.61,112.75],[128.66,113.93],[128.35,114.26],[127.22,115.45],[126.71,115.95],[125.62,116.95],[125.11,117.39],[123.78,118.45],[123.44,118.71],[123.28,118.82],[123.44,117.24],[126.85,110.43],[131.61,108.11]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 3","ix":3,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[8.47,-1.53],[2.15,3.41],[-1.62,3.2],[-4.85,1.78],[-2.33,-0.94],[-0.64,-1.77],[1.67,-1.59],[0.54,-3.2],[-0.04,-1.29],[1.35,-0.59],[-0.24,-0.55],[-0.56,0.25],[-1.51,0.96],[-0.67,0.5],[0,0]],"o":[[-3.27,0.1],[-1.68,-2.65],[3.37,-6.68],[2.97,-1.09],[1.9,0.77],[-2.16,0.31],[-2.08,1.98],[-0.18,1.03],[-1.27,0.77],[-0.56,0.25],[0.24,0.56],[1.63,-0.71],[0.71,-0.45],[0,0],[-1.66,1.21]],"v":[[111.97,128.63],[102.25,124.17],[102.15,114.53],[119.01,102.08],[127.22,101.84],[131.28,105.96],[125.34,108.84],[121.28,116.87],[121.08,120.28],[117.16,122.35],[116.59,123.8],[118.04,124.36],[122.78,121.83],[124.85,120.41],[126.72,123.05]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 4","ix":4,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[-2.24,0],[0,0],[0,-0.24],[0.04,-0.28],[0.03,-0.16],[0.03,-0.12],[0.09,-0.22],[0.02,-0.06],[0.14,-0.26],[0.02,-0.03],[0.18,-0.29],[0,0],[0.77,-0.88],[1.8,-0.66],[0,0],[-1.23,1.45]],"o":[[0,0],[0.02,0.23],[-0.01,0.27],[-0.03,0.16],[-0.03,0.12],[-0.06,0.21],[-0.02,0.06],[-0.1,0.26],[-0.01,0.03],[-0.14,0.28],[0,0.01],[-0.5,0.81],[-1.7,0.02],[-0.01,0],[0.38,-2.11],[1.59,-1.9]],"v":[[126.84,91.52],[126.88,91.52],[126.91,92.23],[126.83,93.06],[126.73,93.54],[126.65,93.9],[126.42,94.56],[126.36,94.74],[126,95.52],[125.96,95.61],[125.47,96.47],[125.46,96.49],[123.54,99.01],[118.25,100.02],[118.23,100.03],[120.67,94.57]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 5","ix":5,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[3.19,-6.32],[0.21,-1.3],[2.25,3.36],[-2.11,3.9],[-4.99,1.76],[-1.97,0],[-1.35,-0.5],[-0.92,-1.96],[1.9,-2.26],[0.29,-3.01]],"o":[[-0.62,1.22],[-3.73,-0.38],[-2.12,-3.2],[4.56,-8.41],[2.13,-0.76],[1.59,0],[2.26,0.84],[-2.7,0.18],[-1.73,2.04],[-5.25,2.21]],"v":[[100.19,113.54],[98.97,117.36],[88.94,112.13],[88.92,100.45],[110.58,85.27],[116.79,84.13],[121.24,84.88],[126.26,89.36],[118.99,93.15],[115.88,100.96]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 6","ix":6,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[-2.22,0],[-0.02,-0.09],[-0.01,-0.09],[0.01,-0.32],[2.24,-2.51],[0.65,-0.23],[1.32,-0.55],[0,0.01],[-1.54,1.83]],"o":[[0.02,0.09],[0.01,0.08],[0.04,0.32],[-0.05,2.07],[-0.65,0.17],[-1.09,0.38],[0,-0.01],[0.16,-2.78],[1.6,-1.89]],"v":[[115.01,74.4],[115.08,74.66],[115.12,74.91],[115.18,75.87],[111.8,82.61],[109.85,83.2],[106.2,84.61],[106.2,84.59],[108.85,77.44]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 7","ix":7,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[3.52,-6.5],[0.14,-0.28],[1.92,2.89],[-2.06,3.8],[-6.06,2.15],[-1.92,0],[-1.32,-0.49],[-0.99,-1.56],[1.82,-2.17],[0.19,-3.25],[-0.01,-0.37]],"o":[[-0.15,0.28],[-3.24,-0.56],[-2.08,-3.11],[4.3,-7.92],[2.08,-0.74],[1.56,0],[1.86,0.69],[-2.59,0.25],[-1.85,2.18],[-0.03,0.37],[-6.19,2.83]],"v":[[86.99,99.41],[86.56,100.25],[78.1,95.32],[78.07,83.93],[99.25,69.08],[105.31,67.97],[109.66,68.71],[114.11,72.26],[107.18,76.03],[104.01,84.46],[103.99,85.57]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 8","ix":8,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[-1.98,0.24],[-0.16,-0.4],[-0.03,-0.12],[-0.03,-0.13],[-0.02,-0.09],[-0.01,-0.12],[0,-0.06],[0.02,-0.27],[0.76,-1.15],[0.2,-0.26],[0.19,-0.21],[0.25,-0.09],[2.16,-1],[-0.02,0.26],[-1.55,1.83]],"o":[[0.25,0.39],[0.05,0.12],[0.05,0.13],[0.02,0.1],[0.03,0.12],[0.01,0.06],[0.02,0.27],[-0.09,1.08],[-0.17,0.25],[-0.16,0.2],[-0.25,0.08],[-1.68,0.59],[0,-0.26],[0.16,-2.77],[1.4,-1.67]],"v":[[100.66,58.48],[101.27,59.67],[101.4,60.04],[101.51,60.44],[101.57,60.72],[101.62,61.08],[101.64,61.25],[101.64,62.05],[100.37,65.36],[99.81,66.13],[99.28,66.76],[98.52,67.01],[92.64,69.4],[92.66,68.62],[95.32,61.48]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 9","ix":9,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[3.1,-5.71],[-0.12,0.21],[1.77,3.02],[-2,3.22],[-5.47,1.58],[-1.45,0],[-1.34,-0.6],[-0.54,-0.42],[1.41,-1.68],[0.19,-3.23],[-0.04,-0.64],[-0.15,0.08]],"o":[[0.12,-0.21],[-3.21,-0.49],[-1.65,-2.82],[4.17,-6.73],[1.57,-0.45],[1.67,0],[0.62,0.27],[-2,0.57],[-1.85,2.2],[-0.04,0.67],[0.15,-0.08],[-5.6,2.8]],"v":[[76.14,82.88],[76.5,82.25],[68.05,77.24],[68.62,67.29],[88.05,55.33],[92.62,54.66],[97.19,55.55],[98.94,56.6],[93.64,60.06],[90.47,68.48],[90.48,70.44],[90.93,70.22]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 10","ix":10,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[-2.2,1.23],[-3.32,-0.3],[-1.22,-0.03],[1.03,-1],[2.83,-0.47],[1.68,0.74]],"o":[[2.63,-1.47],[1.17,0.11],[-0.85,1.19],[-2.62,2.56],[-1.91,0.31],[0.34,-2.88]],"v":[[69.91,38.36],[79.01,37.47],[82.59,37.71],[79.77,41.01],[71.45,45.63],[65.86,44.96]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 11","ix":11,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.23,0.24],[0.33,-0.04],[0,0],[0.01,-0.55],[0,0],[4.39,2.81],[0.58,0.39],[2.08,1.51],[3.97,2.27],[5.57,0.12],[0.9,-0.08],[0.86,-0.18],[0.38,-0.1],[0.03,-0.01],[2.43,-1.03],[1.28,-0.48],[0.41,-0.14],[0,-0.01],[1.35,-0.21],[0,0],[0,0],[0,0],[0.15,-3],[-0.16,-0.91],[-3.98,-2.66],[-0.97,-0.47],[1.56,-2.5],[-2.06,-3.52],[-4.12,-0.79],[-0.02,0.05],[-2.29,-3.43],[-3.63,-0.72],[-2.05,-3.07],[-5.02,-0.5],[-1.06,-1.68],[-4.8,0],[-0.06,0.01],[-4.44,3.96],[0,0],[-2.36,0.11],[3.23,4.63],[0,0],[-1.51,1.62],[-0.35,0.5],[-1.03,0],[0,0],[-1.6,-0.18],[-0.42,-0.04],[0,0],[-0.61,-0.02],[0,0],[0,0],[-0.07,0.56],[0,0]],"o":[[-0.24,-0.24],[0,0],[-0.55,0.07],[0,0],[-4.78,-0.08],[-0.59,-0.37],[-2.15,-1.45],[-3.61,-2.64],[-6.18,-3.54],[-0.93,-0.02],[-0.9,0.08],[-0.39,0.07],[-0.03,0],[-2.61,0.67],[-1.31,0.56],[-0.41,0.16],[-0.01,0],[-1.32,0.44],[0,0],[0,0],[0,0],[-1.93,1.89],[-0.05,0.9],[0.72,4.05],[0.92,0.61],[-2.49,1.75],[-2.42,3.9],[1.77,3.02],[0.02,-0.04],[-1.79,4.21],[2.21,3.33],[-1.15,3.86],[2.31,3.46],[0.02,2.09],[2.16,3.41],[0,0],[1.8,-0.3],[0,0],[1.14,1.65],[6.67,-0.29],[0,0],[1.51,-1.25],[0.41,-0.43],[0.99,-1.36],[0,0],[1.54,0.03],[0.41,0.05],[0,0],[-0.01,0.6],[0,0],[0,0],[0.55,0],[0,0],[0.04,-0.33]],"v":[[184.68,32.85],[183.77,32.54],[160.57,35.29],[159.6,36.37],[159.38,50.54],[145.47,46.91],[143.71,45.75],[137.33,41.22],[126.01,33.59],[108.2,28.07],[105.46,28.16],[102.81,28.55],[101.67,28.81],[101.59,28.83],[94.05,31.6],[90.19,33.18],[88.96,33.62],[88.95,33.63],[84.95,34.64],[73.63,18.74],[58.85,27.32],[65.9,37.26],[62.6,44.9],[62.77,47.63],[70.18,58.18],[73.03,59.78],[66.75,66.13],[66.15,78.35],[75.46,84.31],[75.52,84.18],[76.27,96.54],[85.78,102.33],[87.12,113.35],[98.78,119.55],[100.39,125.34],[111.63,130.83],[112.33,130.78],[127.95,124.79],[137.11,137.71],[142.65,140.14],[151.28,127.79],[143.87,117.39],[148.54,113.07],[149.67,111.63],[152.41,109.38],[152.43,109.38],[157.23,109.78],[158.48,109.92],[158.34,119.1],[159.41,120.22],[174.17,120.62],[174.2,120.62],[175.29,119.64],[184.99,33.75]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,0],[0.14,-0.11],[-0.14,0.12]],"o":[[-0.14,0.12],[0.14,-0.11],[-0.01,0]],"v":[[94.7,70.88],[94.28,71.21],[94.71,70.88]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 3","ix":3,"cix":2,"np":2,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":3,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.878,-0.289],[0.722,0.366],[0.275,0.838],[-0.365,0.722],[-0.837,0.275],[-0.702,-0.372],[-0.275,-0.835],[0.345,-0.714]],"o":[[-0.837,0.275],[-0.722,-0.363],[-0.275,-0.835],[0.365,-0.722],[0.878,-0.289],[0.701,0.372],[0.275,0.838],[-0.344,0.716]],"v":[[38.313,-13.353],[35.975,-13.489],[34.479,-15.292],[34.614,-17.628],[36.417,-19.125],[38.786,-19],[40.25,-17.188],[40.146,-14.86]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 2","ix":2,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.376,-0.124],[0.319,0.197],[0.206,0.488],[0,0],[-0.254,0.571],[-0.753,0.247],[-0.521,-0.316],[-0.247,-0.754],[0,0],[0.14,-0.347]],"o":[[-0.377,0.123],[-0.32,-0.196],[0,0],[-0.29,-0.739],[0.252,-0.569],[0.753,-0.247],[0.52,0.315],[0,0],[0.164,0.502],[-0.141,0.349]],"v":[[34.788,-24.081],[33.745,-24.19],[32.956,-25.215],[22.141,-54.951],[22.087,-56.916],[23.596,-58.14],[25.506,-58.038],[26.658,-56.435],[35.527,-26.06],[35.564,-24.788]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[6.707,-2.442],[0,0],[-1.598,6.957],[0,0],[-5.209,-3.934],[0,0]],"o":[[0,0],[-6.708,2.442],[0,0],[1.461,-6.362],[0,0],[5.696,4.302]],"v":[[77.788,-14.555],[7.405,11.071],[-4.452,0.595],[10.965,-66.546],[25.168,-71.716],[80.134,-30.202]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0.2314,0.8784,0.5804],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[38,-29],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0,0],"t":75},{"s":[100,100],"t":81}],"ix":3,"x":"var $bm_rt;\nvar fx = effect('ŝlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[38,-29],"ix":2,"x":"var $bm_rt;\nvar fx = effect('ŝlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":3},{"ty":4,"nm":"Layer 3","sr":1,"st":0,"op":250,"ip":0,"hd":false,"ddd":0,"bm":0,"hasMask":false,"td":1,"ao":0,"ks":{"a":{"a":0,"k":[184.998,140.149,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[447.029,406,0],"t":0,"ti":[17.137,0,0],"to":[0,17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,437.029,0],"t":9.375,"ti":[0,17.137,0],"to":[-17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[384.971,406,0],"t":18.75,"ti":[-17.137,0,0],"to":[0,-17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,374.971,0],"t":28.125,"ti":[0,-17.137,0],"to":[17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[447.029,406,0],"t":37.5,"ti":[17.137,0,0],"to":[0,17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,437.029,0],"t":46.875,"ti":[0,17.137,0],"to":[-17.137,0,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[384.971,406,0],"t":56.25,"ti":[-17.137,0,0],"to":[0,-17.137,0]},{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[416,374.971,0],"t":65.625,"ti":[0,-17.137,0],"to":[17.137,0,0]},{"s":[447.029,406,0],"t":75}],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[{"ty":5,"mn":"Pseudo/Duik Kleaner v3.2","nm":"ŝlosilo pli pura","ix":1,"en":1,"ef":[{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0001","nm":"Anticipation","ix":1,"v":{"a":0,"k":0,"ix":1}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0002","nm":"Smart Interpolation","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0003","nm":"Follow Through","ix":3,"v":{"a":0,"k":1,"ix":3}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0004","nm":"Anticipation","ix":4,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0005","nm":"Duration (s)","ix":5,"v":{"a":0,"k":0.3,"ix":5}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0006","nm":"Amplitude","ix":6,"v":{"a":0,"k":50,"ix":6}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0007","nm":"","ix":7,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0008","nm":"Interpolation","ix":8,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0009","nm":"Slow In","ix":9,"v":{"a":0,"k":60,"ix":9}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0010","nm":"Slow Out","ix":10,"v":{"a":0,"k":25,"ix":10}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0011","nm":"","ix":11,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0012","nm":"Follow Through","ix":12,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0013","nm":"Elasticity","ix":13,"v":{"a":0,"k":10,"ix":13}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0014","nm":"Elasticity random","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0015","nm":"Damping","ix":15,"v":{"a":0,"k":50,"ix":15}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0016","nm":"Damping random","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0017","nm":"Bounce","ix":17,"v":{"a":0,"k":0,"ix":17}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0018","nm":"","ix":18,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0019","nm":"Spatial Options","ix":19,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0020","nm":"Smart Interpolation","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0021","nm":"Mode","ix":21,"v":{"a":0,"k":1,"ix":21}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0022","nm":"Overlap (simulation)","ix":22,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0023","nm":"Overlap","ix":23,"v":{"a":0,"k":1,"ix":23}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0024","nm":"Delay (s)","ix":24,"v":{"a":0,"k":0.05,"ix":24}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0025","nm":"Overlap random","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0026","nm":"","ix":26,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0027","nm":"Soft Body (simulation)","ix":27,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0028","nm":"Soft Body","ix":28,"v":{"a":0,"k":1,"ix":28}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0029","nm":"Soft-Body Flexibility","ix":29,"v":{"a":0,"k":100,"ix":29}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0030","nm":"","ix":30,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0031","nm":"","ix":31,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0032","nm":"Precision","ix":32,"v":{"a":0,"k":1,"ix":32}}]}],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.04,-0.33],[0,0],[0.55,0],[0,0],[0,0],[-0.01,0.6],[0,0],[0.41,0.05],[1.54,0.03],[0,0],[0.99,-1.36],[0.41,-0.43],[1.51,-1.25],[0,0],[6.67,-0.29],[1.14,1.65],[0,0],[1.8,-0.3],[0,0],[2.16,3.41],[0.02,2.09],[2.31,3.46],[-1.15,3.86],[2.21,3.33],[-1.79,4.21],[0.02,-0.04],[1.77,3.02],[-2.42,3.9],[-2.49,1.75],[0.92,0.61],[0.72,4.05],[-0.05,0.9],[-1.93,1.89],[0,0],[9.24,-0.38],[11.58,13.46],[-4.86,19.46],[-18.74,8.5],[-0.45,0.2],[-9.55,-0.85],[-1.12,-0.28],[-7.29,-4.26],[-1.5,-0.82],[-3.35,-15.99],[12.76,-15.02],[3.37,-2.73],[0,0],[-1.32,0.44],[-0.01,0],[-0.41,0.16],[-1.31,0.56],[-2.61,0.67],[-0.03,0],[-0.39,0.07],[-0.9,0.08],[-0.93,-0.02],[-6.18,-3.54],[-3.61,-2.64],[-2.15,-1.45],[-0.59,-0.37],[-4.78,-0.08],[0,0],[-0.55,0.07],[0,0],[-0.24,-0.24]],"o":[[0,0],[-0.07,0.56],[0,0],[0,0],[-0.61,-0.02],[0,0],[-0.42,-0.04],[-1.6,-0.18],[0,0],[-1.03,0],[-0.35,0.5],[-1.51,1.62],[0,0],[3.23,4.63],[-2.36,0.11],[0,0],[-4.44,3.96],[-0.06,0.01],[-4.8,0],[-1.06,-1.68],[-5.02,-0.5],[-2.05,-3.07],[-3.63,-0.72],[-2.29,-3.43],[-0.02,0.05],[-4.12,-0.79],[-2.06,-3.52],[1.56,-2.5],[-0.97,-0.47],[-3.98,-2.66],[-0.16,-0.91],[0.15,-3],[0,0],[-8.64,4.18],[-18.84,0.78],[-12.17,-14.16],[4.89,-19.48],[0.45,-0.22],[9.27,-3.92],[1.18,0.1],[5.48,1.37],[1.51,0.86],[13.96,7.7],[3.68,17.8],[-2.81,3.3],[0,0],[1.35,-0.21],[0,-0.01],[0.41,-0.14],[1.28,-0.48],[2.43,-1.03],[0.03,-0.01],[0.38,-0.1],[0.86,-0.18],[0.9,-0.08],[5.57,0.12],[3.97,2.27],[2.08,1.51],[0.58,0.39],[4.39,2.81],[0,0],[0.01,-0.55],[0,0],[0.33,-0.04],[0.23,0.24]],"v":[[184.99,33.75],[175.29,119.64],[174.2,120.62],[174.17,120.62],[159.41,120.22],[158.34,119.1],[158.48,109.92],[157.23,109.78],[152.43,109.38],[152.41,109.38],[149.67,111.63],[148.54,113.07],[143.87,117.39],[151.28,127.79],[142.65,140.14],[137.11,137.71],[127.95,124.79],[112.33,130.78],[111.63,130.83],[100.39,125.34],[98.78,119.55],[87.12,113.35],[85.78,102.33],[76.27,96.54],[75.52,84.18],[75.46,84.31],[66.15,78.35],[66.75,66.13],[73.03,59.78],[70.18,58.18],[62.77,47.63],[62.6,44.9],[65.9,37.26],[57.46,26.11],[30.23,33.15],[-18.2,12.72],[-30.32,-41.36],[7.99,-87.28],[9.37,-87.9],[38.24,-92.51],[41.7,-92.09],[62.98,-84.86],[67.56,-82.46],[96.06,-45.23],[81.14,7.94],[71.81,16.99],[84.95,34.64],[88.95,33.63],[88.96,33.62],[90.19,33.18],[94.05,31.6],[101.59,28.83],[101.67,28.81],[102.81,28.55],[105.46,28.16],[108.2,28.07],[126.01,33.59],[137.33,41.22],[143.71,45.75],[145.47,46.91],[159.38,50.54],[159.6,36.37],[160.57,35.29],[183.77,32.54],[184.68,32.85]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0.2157,0.4157],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":4},{"ty":4,"nm":"Layer 4","sr":1,"st":0,"op":250,"ip":0,"hd":false,"ddd":0,"bm":0,"tt":1,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[-65.021,-37.592,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[190.979,218.408,0],"t":0,"ti":[0,0,0],"to":[-1.667,-3.333,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[180.979,198.408,0],"t":12.5,"ti":[0,0,0],"to":[0,0,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[190.979,218.408,0],"t":25,"ti":[0,0,0],"to":[0,0,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[180.979,198.408,0],"t":37.5,"ti":[-1.667,-3.333,0],"to":[0,0,0]},{"s":[190.979,218.408,0],"t":50}],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":3,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,0],[1.039,1.872],[8.122,16.947],[8.126,15.074],[-0.017,0.045],[-0.043,0.016],[-70.265,29.965],[-2.49,-25.027],[0.225,-0.073],[21.348,-7.761],[24.395,-4.602]],"o":[[-0.922,-1.766],[-9.132,-16.469],[-7.32,-15.273],[-0.028,-0.053],[0.014,-0.036],[67.152,-24.74],[0.847,11.605],[0.024,0.237],[-15.004,4.855],[-41.075,14.934],[0,0]],"v":[[-123.855,54.181],[-126.77,48.716],[-152.422,-2.224],[-175.437,-48.364],[-175.455,-48.517],[-175.367,-48.597],[33.496,-129.965],[45.372,-2.062],[45.036,-1.543],[-11.481,18.403],[-123.5,54.861]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 2","ix":2,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.44,4.415],[0,0],[0.758,10.778],[2.515,1.536],[2.714,-1.165],[67.115,-24.727],[0.955,-2.528],[-1.293,-2.397],[-7.295,-15.221],[-9.26,-16.698],[-0.898,-1.723],[0,0],[-3.358,0],[-0.559,0.104],[-42.024,15.153],[-14.637,4.74]],"o":[[0,0],[-2.503,-25.083],[-0.207,-2.957],[-2.52,-1.542],[-70.165,29.913],[-2.546,0.938],[-0.96,2.539],[8.011,14.86],[8.18,17.068],[0.979,1.764],[0,0],[1.544,2.956],[0.55,0],[25,-4.699],[20.896,-7.535],[4.219,-1.366]],"v":[[54.573,-2.485],[54.573,-2.485],[42.652,-130.848],[38.368,-137.919],[30.128,-138.51],[-178.547,-57.227],[-184.056,-51.77],[-183.533,-44.003],[-160.711,1.759],[-134.812,53.176],[-132.007,58.439],[-131.607,59.202],[-123.537,64.067],[-121.872,63.913],[-7.216,26.885],[48.054,7.492]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":5},{"ty":4,"nm":"Layer 5","sr":1,"st":0,"op":250,"ip":0,"hd":false,"ddd":0,"bm":0,"hasMask":false,"ao":0,"ks":{"a":{"a":0,"k":[-47.84,-5.721,0],"ix":1},"s":{"a":0,"k":[100,100,100],"ix":6},"sk":{"a":0,"k":0},"p":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[208.16,250.279,0],"t":0,"ti":[0,0,0],"to":[-1.667,-3.333,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[198.16,230.279,0],"t":12.5,"ti":[0,0,0],"to":[0,0,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[208.16,250.279,0],"t":25,"ti":[0,0,0],"to":[0,0,0]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[198.16,230.279,0],"t":37.5,"ti":[-1.667,-3.333,0],"to":[0,0,0]},{"s":[208.16,250.279,0],"t":50}],"ix":2},"r":{"a":0,"k":0,"ix":10},"sa":{"a":0,"k":0},"o":{"a":0,"k":100,"ix":11}},"ef":[{"ty":5,"mn":"Pseudo/Duik Kleaner v3.2","nm":"ŝlosilo pli pura","ix":1,"en":1,"ef":[{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0001","nm":"Anticipation","ix":1,"v":{"a":0,"k":0,"ix":1}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0002","nm":"Smart Interpolation","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0003","nm":"Follow Through","ix":3,"v":{"a":0,"k":1,"ix":3}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0004","nm":"Anticipation","ix":4,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0005","nm":"Duration (s)","ix":5,"v":{"a":0,"k":0.3,"ix":5}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0006","nm":"Amplitude","ix":6,"v":{"a":0,"k":50,"ix":6}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0007","nm":"","ix":7,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0008","nm":"Interpolation","ix":8,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0009","nm":"Slow In","ix":9,"v":{"a":0,"k":60,"ix":9}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0010","nm":"Slow Out","ix":10,"v":{"a":0,"k":25,"ix":10}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0011","nm":"","ix":11,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0012","nm":"Follow Through","ix":12,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0013","nm":"Elasticity","ix":13,"v":{"a":0,"k":10,"ix":13}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0014","nm":"Elasticity random","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0015","nm":"Damping","ix":15,"v":{"a":0,"k":50,"ix":15}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0016","nm":"Damping random","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0017","nm":"Bounce","ix":17,"v":{"a":0,"k":0,"ix":17}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0018","nm":"","ix":18,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0019","nm":"Spatial Options","ix":19,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0020","nm":"Smart Interpolation","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0021","nm":"Mode","ix":21,"v":{"a":0,"k":1,"ix":21}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0022","nm":"Overlap (simulation)","ix":22,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0023","nm":"Overlap","ix":23,"v":{"a":0,"k":1,"ix":23}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0024","nm":"Delay (s)","ix":24,"v":{"a":0,"k":0.05,"ix":24}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0025","nm":"Overlap random","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0026","nm":"","ix":26,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0027","nm":"Soft Body (simulation)","ix":27,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0028","nm":"Soft Body","ix":28,"v":{"a":0,"k":1,"ix":28}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0029","nm":"Soft-Body Flexibility","ix":29,"v":{"a":0,"k":100,"ix":29}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0030","nm":"","ix":30,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0031","nm":"","ix":31,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0032","nm":"Precision","ix":32,"v":{"a":0,"k":1,"ix":32}}]},{"ty":5,"mn":"Pseudo/Duik Kleaner v3.2","nm":"ŝlosilo pli pura 2","ix":2,"en":1,"ef":[{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0001","nm":"Anticipation","ix":1,"v":{"a":0,"k":0,"ix":1}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0002","nm":"Smart Interpolation","ix":2,"v":{"a":0,"k":0,"ix":2}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0003","nm":"Follow Through","ix":3,"v":{"a":0,"k":1,"ix":3}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0004","nm":"Anticipation","ix":4,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0005","nm":"Duration (s)","ix":5,"v":{"a":0,"k":0.3,"ix":5}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0006","nm":"Amplitude","ix":6,"v":{"a":0,"k":50,"ix":6}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0007","nm":"","ix":7,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0008","nm":"Interpolation","ix":8,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0009","nm":"Slow In","ix":9,"v":{"a":0,"k":60,"ix":9}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0010","nm":"Slow Out","ix":10,"v":{"a":0,"k":25,"ix":10}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0011","nm":"","ix":11,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0012","nm":"Follow Through","ix":12,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0013","nm":"Elasticity","ix":13,"v":{"a":0,"k":10,"ix":13}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0014","nm":"Elasticity random","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0015","nm":"Damping","ix":15,"v":{"a":0,"k":50,"ix":15}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0016","nm":"Damping random","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0017","nm":"Bounce","ix":17,"v":{"a":0,"k":0,"ix":17}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0018","nm":"","ix":18,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0019","nm":"Spatial Options","ix":19,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0020","nm":"Smart Interpolation","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0021","nm":"Mode","ix":21,"v":{"a":0,"k":1,"ix":21}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0022","nm":"Overlap (simulation)","ix":22,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0023","nm":"Overlap","ix":23,"v":{"a":0,"k":1,"ix":23}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0024","nm":"Delay (s)","ix":24,"v":{"a":0,"k":0.05,"ix":24}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0025","nm":"Overlap random","ix":25,"v":{"a":0,"k":0,"ix":25}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0026","nm":"","ix":26,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0027","nm":"Soft Body (simulation)","ix":27,"v":0},{"ty":7,"mn":"Pseudo/Duik Kleaner v3.2-0028","nm":"Soft Body","ix":28,"v":{"a":0,"k":1,"ix":28}},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0029","nm":"Soft-Body Flexibility","ix":29,"v":{"a":0,"k":100,"ix":29}},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0030","nm":"","ix":30,"v":0},{"ty":6,"mn":"Pseudo/Duik Kleaner v3.2-0031","nm":"","ix":31,"v":0},{"ty":0,"mn":"Pseudo/Duik Kleaner v3.2-0032","nm":"Precision","ix":32,"v":{"a":0,"k":1,"ix":32}}]}],"shapes":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":1,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,0],[0.14,-0.11],[-0.14,0.12]],"o":[[-0.14,0.12],[0.14,-0.11],[-0.01,0]],"v":[[94.7,70.88],[94.28,71.21],[94.71,70.88]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 3","ix":2,"cix":2,"np":2,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-2.811,1.689],[-1.539,-3.367]],"o":[[2.811,-1.689],[1.539,3.367],[0,0]],"v":[[25.185,80.585],[33.619,75.518],[38.236,85.619]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[32.461,75.301],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0,0],"t":75},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[100,100],"t":83},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0,0],"t":90},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[100,100],"t":98},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0,0],"t":105},{"s":[100,100],"t":113}],"ix":3,"x":"var $bm_rt;\nvar fx = effect('ŝlosilo pli pura');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[32.461,75.301],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 2","ix":2,"cix":2,"np":3,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":false,"i":[[0,0],[-1.866,-12.321],[-10.177,-7.192],[-5.683,1.228],[2.13,5.411],[4.536,-3.779],[-2.066,-5.531],[-4.747,-3.51],[-21.925,7.805],[-5.761,22.549]],"o":[[-7.59,9.884],[1.866,12.321],[4.748,3.356],[5.683,-1.228],[-2.162,-5.494],[-4.536,3.779],[2.066,5.531],[18.714,13.836],[21.925,-7.805],[0,0]],"v":[[-106.062,31.328],[-115.144,66.56],[-96.036,97.522],[-79.743,102.162],[-71.457,89.26],[-86.363,86.358],[-89.713,102.622],[-78.452,115.969],[-12.112,125.813],[33.084,76.262]]},"ix":2}},{"ty":"tm","bm":0,"hd":false,"mn":"ADBE Vector Filter - Trim","nm":"Trim Paths 1","ix":2,"e":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":50},{"o":{"x":0.333,"y":0},"i":{"x":0.833,"y":1},"s":[100],"t":75},{"s":[85],"t":150}],"ix":2},"o":{"a":1,"k":[{"o":{"x":0.167,"y":0.167},"i":{"x":0.833,"y":0.833},"s":[0],"t":75},{"s":[360],"t":150}],"ix":3},"s":{"a":0,"k":0,"ix":1},"m":1},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":2,"lj":2,"ml":1,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2.203,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[-37,83],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[-63,94],"ix":2},"r":{"a":0,"k":36,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 4","ix":3,"cix":2,"np":4,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[1.791,-0.58],[37.396,-7.029],[0.683,1.304],[0,0],[1.006,1.813],[8.145,16.997],[8.083,14.994],[-0.376,0.994],[-0.994,0.366],[-3.661,1.351],[-0.255,-0.662],[0,0],[0.285,0.53],[-5.575,2.377],[-0.444,0],[-0.528,-0.323],[-0.077,-1.095],[-2.476,-24.881]],"o":[[-43.859,14.192],[-1.456,0.275],[0,0],[-0.936,-1.793],[-9.178,-16.552],[-7.304,-15.24],[-0.509,-0.945],[0.372,-0.985],[3.637,-1.34],[0.198,0.516],[0,0],[-0.325,-0.559],[5.587,-2.336],[0.43,-0.183],[0.595,0],[0.924,0.565],[0.758,10.779],[0.186,1.873]],"v":[[46.114,1.786],[-122.925,58.314],[-126.56,56.563],[-126.958,55.8],[-129.831,50.413],[-155.578,-0.711],[-178.518,-46.705],[-178.729,-49.755],[-176.577,-51.881],[-165.624,-55.921],[-164.96,-54.197],[16.522,-124.583],[15.617,-126.21],[32.363,-133.272],[33.686,-133.546],[35.396,-133.06],[36.971,-130.449],[48.855,-2.407]]},"ix":2}},{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 2","ix":2,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0.28,2.81],[0.764,10.864],[1.538,0.939],[1.666,-0.715],[5.634,-2.355],[0.828,2.166],[1.74,1.578],[1.044,-0.503],[1.864,-0.83],[3.154,-1.373],[6.221,-2.592],[16.487,-7.317],[0.151,2.365],[0.506,7.423],[2.02,-1.08],[24.695,-12.782],[-0.96,-2.855],[-1.315,-3.669],[0.179,-0.113],[2.67,-1.24],[-0.465,-2.568],[-0.716,-1.853],[-0.65,-1.611],[-0.149,-0.385],[3.627,-1.336],[0.597,-1.581],[-0.811,-1.504],[-7.293,-15.217],[-9.211,-16.61],[-0.927,-1.777],[0,0],[-2.05,0],[-0.34,0.063],[-43.976,14.245]],"o":[[-2.448,-24.53],[-0.127,-1.812],[-1.536,-0.939],[-5.621,2.396],[-0.892,-1.851],[-0.667,-1.721],[-0.848,-0.736],[-1.754,0.813],[-3.19,1.323],[-6.299,2.632],[-16.667,7.064],[-1.996,0.88],[-0.557,-7.388],[-0.201,-2.498],[-24.695,12.782],[-2.469,1.264],[1.169,3.636],[0.062,0.215],[-2.647,1.208],[-1.887,0.862],[0.337,1.942],[0.591,1.593],[0.185,0.476],[-3.651,1.348],[-1.593,0.588],[-0.601,1.589],[8.059,14.949],[8.16,17.026],[0.997,1.796],[0,0],[0.967,1.849],[0.338,0],[37.128,-6.979],[2.686,-0.87]],"v":[[51.091,-2.138],[39.161,-130.603],[36.542,-134.933],[31.501,-135.291],[14.615,-128.171],[12.148,-134.023],[8.957,-140.654],[5.769,-140.906],[0.229,-138.45],[-9.265,-134.354],[-27.992,-126.456],[-77.813,-105.011],[-82.294,-108.093],[-83.384,-131.022],[-88.112,-134.064],[-161.191,-96.103],[-163.805,-88.857],[-160.261,-78.066],[-160.475,-77.47],[-168.425,-73.732],[-170.911,-69.57],[-168.761,-64.01],[-166.907,-59.246],[-166.414,-57.971],[-177.337,-53.943],[-180.783,-50.531],[-180.452,-45.664],[-157.558,0.238],[-131.751,51.478],[-128.905,56.817],[-128.506,57.581],[-123.537,60.568],[-122.518,60.473],[46.976,4.162]]},"ix":2}},{"ty":"st","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Stroke","nm":"Stroke 1","lc":1,"lj":1,"ml":10,"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0.75,"ix":5},"c":{"a":0,"k":[0,0,0],"ix":3}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0,0,0],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 5","ix":4,"cix":2,"np":1,"it":[{"ty":"gr","bm":0,"hd":false,"mn":"ADBE Vector Group","nm":"Group 1","ix":1,"cix":2,"np":2,"it":[{"ty":"sh","bm":0,"hd":false,"mn":"ADBE Vector Shape - Group","nm":"Path 1","ix":1,"d":1,"ks":{"a":0,"k":{"c":true,"i":[[0,0],[0,0],[0,0],[0,0]],"o":[[0,0],[0,0],[0,0],[0,0]],"v":[[-121.885,33.285],[-138.024,-18.641],[-211.494,4.194],[-195.355,56.12]]},"ix":2}},{"ty":"fl","bm":0,"hd":false,"mn":"ADBE Vector Graphic - Fill","nm":"Fill 1","c":{"a":0,"k":[0.8588,0.8745,0.902],"ix":4},"r":1,"o":{"a":0,"k":100,"ix":5}},{"ty":"tr","a":{"a":0,"k":[-168,21],"ix":1},"s":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0,0],"t":50},{"s":[100,100],"t":57}],"ix":3,"x":"var $bm_rt;\nvar fx = effect('ŝlosilo pli pura 2');\nvar doAnticipation = fx(1).value;\nvar doInterpolation = fx(2).value;\nvar doFollowThrough = fx(3).value;\nvar damping = $bm_div(fx(15).value, 10);\nvar elasticity = $bm_div(fx(13).value, 10);\nvar bounce = fx(17).value;\nvar anticipationDuration = fx(5).value;\nvar anticipationQuantity = $bm_div(fx(6).value, 100);\nvar slowIn = $bm_div(fx(9).value, 100);\nvar slowOut = $bm_div(fx(10).value, 100);\nvar spatialMode = fx(21).value;\nvar spatialDoInterpolation = fx(20).value;\nvar moBlurPrecision = fx(32).value;\nvar elasticityRandom = fx(14).value;\nvar dampingRandom = fx(16).value;\nvar softBody = fx(28).value;\nvar flexibility = $bm_div(fx(29).value, 100);\nvar doOverlap = fx(23).value;\nvar overlapDuration = fx(24).value;\nvar overlapRandom = fx(25).value;\nvar threshold = $bm_div($bm_div(1, moBlurPrecision), 1000);\nvar zeroValue;\nif ($bm_isInstanceOfArray(value)) {\n    if (value.length == 2)\n        zeroValue = [\n            0,\n            0\n        ];\n    else if (value.length == 3)\n        zeroValue = [\n            0,\n            0,\n            0\n        ];\n    else if (value.length == 4)\n        zeroValue = [\n            0,\n            0,\n            0,\n            0\n        ];\n} else\n    zeroValue = 0;\nvar isThisSpatial = isSpatial(thisProperty);\nvar isThisPosition = thisProperty === $bm_transform.position;\nvar simulate = false;\nif (isThisSpatial) {\n    doInterpolation = doInterpolation && spatialDoInterpolation;\n    if (isThisPosition && thisProperty.numKeys > 0) {\n        doOverlap = false;\n        simulate = false;\n    } else {\n        simulate = spatialMode == 2;\n        doOverlap = overlapDuration != 0 && doOverlap && simulate;\n    }\n} else {\n    doOverlap = false;\n}\nif (!doOverlap) {\n    overlapDuration = 0;\n}\nif (simulate && softBody && isThisSpatial && !isThisPosition && (doFollowThrough || doOverlap)) {\n    var distanceRatio = $bm_div(length(valueAtTime(0), $bm_transform.anchorPoint), $bm_div(thisLayer.width, 2));\n    distanceRatio = $bm_div($bm_sum(1, $bm_mul(distanceRatio, flexibility)), 2);\n    if (doFollowThrough) {\n        elasticity = $bm_div(elasticity, distanceRatio);\n        damping = $bm_div(damping, distanceRatio);\n    }\n    if (doOverlap) {\n        overlapDuration = $bm_mul(overlapDuration, distanceRatio);\n    }\n}\nseedRandom(0, true);\nif (doFollowThrough) {\n    if (elasticityRandom > 0)\n        elasticity = addNoise(elasticity, elasticityRandom);\n    if (dampingRandom > 0)\n        damping = addNoise(damping, dampingRandom);\n}\nif (doOverlap) {\n    if (doOverlap && overlapRandom > 0)\n        overlapDuration = addNoise(overlapDuration, overlapRandom);\n}\nvar result = value;\nfunction isSpatial(prop) {\n    if (!(prop.value instanceof Array))\n        return false;\n    if (prop.value.length != 2 && prop.value.length != 3)\n        return false;\n    try {\n        if (typeof prop.speed !== 'undefined')\n            return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction addNoise(val, quantity) {\n    var randomValue = random(0.9, 1.1);\n    var noiseValue = noise($bm_mul(valueAtTime(0), randomValue));\n    noiseValue = $bm_mul(noiseValue, $bm_div(quantity, 100));\n    return $bm_mul(val, $bm_sum(noiseValue, 1));\n}\nfunction isAfterLastKey() {\n    if (numKeys == 0)\n        return false;\n    var nKey = nearestKey(time);\n    return nKey.time <= time && nKey.index == numKeys;\n}\nfunction isStill(t, threshold) {\n    var d = $bm_sub(valueAtTime(t), valueAtTime($bm_sum(t, framesToTime(1))));\n    if ($bm_isInstanceOfArray(d)) {\n        for (var i = 0; i < d.length; i++) {\n            d[i] = Math.abs(d[i]);\n            if (d[i] >= threshold) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        d = Math.abs(d);\n        return d < threshold;\n    }\n}\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return t;\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return t;\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction getPropWorldSpeed(t, prop) {\n    return length(getPropWorldVelocity(t, prop));\n}\nfunction getPrevKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time <= t)\n        return nKey;\n    if (nKey.index > 1)\n        return key($bm_sub(nKey.index, 1));\n    return null;\n}\nfunction getNextKey(t) {\n    if (numKeys == 0)\n        return null;\n    var nKey = nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < numKeys)\n        return key($bm_sum(nKey.index, 1));\n    return null;\n}\nfunction getPropWorldVelocity(t, prop) {\n    return $bm_mul($bm_sub(getPropWorldValue($bm_sum(t, 0.005), prop), getPropWorldValue($bm_sub(t, 0.005), prop)), 100);\n}\nfunction getLayerWorldPos(t, l) {\n    return l.toWorld(l.anchorPoint, t);\n}\nfunction getPropWorldValue(t, prop) {\n    if (isPosition(prop))\n        return getLayerWorldPos(t, thisLayer);\n    return thisLayer.toWorld(prop.valueAtTime(t), t);\n}\nfunction isPosition(prop) {\n    return prop === $bm_transform.position;\n}\nfunction isKeyTop(k, axis) {\n    var prevSpeed = velocityAtTime($bm_sub(k.time, threshold));\n    var nextSpeed = velocityAtTime($bm_sum(k.time, threshold));\n    if ($bm_isInstanceOfArray(value)) {\n        prevSpeed = prevSpeed[axis];\n        nextSpeed = nextSpeed[axis];\n    }\n    if (Math.abs(prevSpeed) < 0.01 || Math.abs(nextSpeed) < 0.01)\n        return true;\n    return $bm_mul(prevSpeed, nextSpeed) < 0;\n}\nfunction anticipate() {\n    var anticipation = zeroValue;\n    if (isAfterLastKey())\n        return anticipation;\n    if (numKeys < 2)\n        return anticipation;\n    var nextKey = getNextKey(time);\n    var aKey = nextKey;\n    if (!isStill(aKey.time - 0.1, 0.1)) {\n        aKey = getPrevKey(time);\n        if (!isStill(aKey.time - 0.1, 0.1))\n            return anticipation;\n    }\n    if (aKey.index == numKeys)\n        return anticipation;\n    var anticipationMiddle = aKey.time;\n    var anticipationStart = $bm_sub(anticipationMiddle, anticipationDuration);\n    var anticipationEnd = key(aKey.index + 1).time;\n    var startValue = anticipation;\n    var midValue = $bm_mul($bm_sum($bm_neg(valueAtTime($bm_sum(anticipationMiddle, anticipationDuration))), aKey.value), anticipationQuantity);\n    var endValue = anticipation;\n    if (time < anticipationStart) {\n        return anticipation;\n    } else if (time < anticipationMiddle) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue[i], midValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationStart, anticipationMiddle, startValue, midValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else if (time <= anticipationEnd) {\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < value.length; i++) {\n                anticipation[i] = bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue[i], endValue[i], [\n                    slowOut,\n                    0,\n                    slowIn,\n                    1\n                ]);\n            }\n            return anticipation;\n        } else {\n            return bezierInterpolation(time, anticipationMiddle, anticipationEnd, midValue, endValue, [\n                slowOut,\n                0,\n                slowIn,\n                1\n            ]);\n        }\n    } else {\n        return anticipation;\n    }\n}\nfunction followThroughAtTime(t) {\n    var fThrough = zeroValue;\n    if (elasticity == 0)\n        return fThrough;\n    var propSpeed;\n    if (!simulate) {\n        if (numKeys < 2)\n            return fThrough;\n        if (nearestKey(t).index == 1)\n            return fThrough;\n        propSpeed = length(velocityAtTime(t));\n        if (propSpeed >= threshold)\n            return fThrough;\n    } else {\n        propSpeed = getPropWorldSpeed(t, thisProperty);\n        if (propSpeed >= threshold)\n            return fThrough;\n    }\n    var fThroughStart = 0;\n    var fThroughTime = 0;\n    if (simulate) {\n        var speedI = getPropWorldSpeed(t, thisProperty);\n        var i = t;\n        while (speedI < threshold && i > 0) {\n            i = $bm_sub(i, $bm_div(thisComp.frameDuration, moBlurPrecision));\n            speedI = getPropWorldSpeed(i, thisProperty);\n        }\n        fThroughStart = i;\n    } else {\n        var fThroughKey = getPrevKey(t);\n        fThroughStart = fThroughKey.time;\n    }\n    if (fThroughStart == 0)\n        return fThrough;\n    fThroughTime = $bm_sub(t, fThroughStart);\n    if (simulate)\n        fThrough = $bm_div(getPropWorldVelocity($bm_sub(fThroughStart, thisComp.frameDuration), thisProperty), 2);\n    else\n        fThrough = $bm_div(velocityAtTime($bm_sub(fThroughStart, thisComp.frameDuration)), 2);\n    if (bounce) {\n        var cycleDamp = Math.exp($bm_mul($bm_mul(fThroughTime, damping), 0.1));\n        var damp = $bm_div(Math.exp($bm_mul(fThroughTime, damping)), $bm_div(elasticity, 2));\n        var cycleDuration = $bm_div(1, $bm_mul(elasticity, 2));\n        cycleDuration = Math.round(timeToFrames(cycleDuration));\n        cycleDuration = framesToTime(cycleDuration);\n        var midDuration = $bm_div(cycleDuration, 2);\n        var maxValue = $bm_mul(fThrough, midDuration);\n        var cycvarime = fThroughTime;\n        var numEndCycles = 1;\n        while (cycvarime > cycleDuration) {\n            cycvarime = $bm_sub(cycvarime, cycleDuration);\n            cycleDuration = $bm_div(cycleDuration, cycleDamp);\n            cycleDuration = Math.round(timeToFrames(cycleDuration));\n            if (cycleDuration < 2) {\n                cycleDuration = 2;\n                numEndCycles++;\n            }\n            cycleDuration = framesToTime(cycleDuration);\n            midDuration = $bm_div(cycleDuration, 2);\n            maxValue = $bm_div($bm_mul(fThrough, midDuration), damp);\n            if (numEndCycles > 100 / damping && maxValue < threshold)\n                return zeroValue;\n        }\n        if (cycvarime < midDuration)\n            fThrough = bezierInterpolation(cycvarime, 0, midDuration, 0, maxValue, [\n                0,\n                0.1,\n                slowIn,\n                1\n            ]);\n        else\n            fThrough = bezierInterpolation(cycvarime, midDuration, cycleDuration, maxValue, 0, [\n                $bm_sub(1, slowIn),\n                0,\n                1,\n                0.9\n            ]);\n    } else {\n        var damp = Math.exp($bm_mul(fThroughTime, damping));\n        var sinus = $bm_mul($bm_mul($bm_mul(elasticity, fThroughTime), 2), Math.PI);\n        sinus = Math.sin(sinus);\n        sinus = $bm_mul($bm_div(0.3, elasticity), sinus);\n        sinus = $bm_div(sinus, damp);\n        if (Math.abs(sinus) < $bm_div(threshold, 100))\n            return 0;\n        fThrough = $bm_mul(fThrough, sinus);\n        if (threshold > 0) {\n            fThrough = $bm_mul(fThrough, $bm_sub(1, $bm_div(propSpeed, threshold)));\n        }\n    }\n    if (bounce) {\n        var prevValue = valueAtTime($bm_sub(fThroughStart, thisComp.frameDuration));\n        var startValue = valueAtTime(fThroughStart);\n        if ($bm_isInstanceOfArray(value)) {\n            for (var i = 0; i < prevValue.length; i++) {\n                if (prevValue[i] > startValue[i])\n                    fThrough[i] = Math.abs(fThrough[i]);\n                if (prevValue[i] < startValue[i])\n                    fThrough[i] = $bm_neg(Math.abs(fThrough[i]));\n            }\n        } else {\n            if (prevValue > startValue)\n                fThrough = Math.abs(fThrough);\n            if (prevValue < startValue)\n                fThrough = $bm_neg(Math.abs(fThrough));\n        }\n    }\n    if (simulate) {\n        if (!isThisPosition) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer));\n            fThrough = $bm_sub(thisLayer.fromWorld(fThrough), thisLayer.anchorPoint);\n        } else if (thisLayer.hasParent) {\n            fThrough = $bm_sum(fThrough, getLayerWorldPos(time, thisLayer.parent));\n            fThrough = $bm_sub(thisLayer.parent.fromWorld(fThrough), thisLayer.parent.anchorPoint);\n        }\n    }\n    return fThrough;\n}\nfunction followThrough() {\n    var propSpeed = length(velocity);\n    if (propSpeed < threshold)\n        return followThroughAtTime($bm_sub(time, overlapDuration));\n    var fThrough = zeroValue;\n    var t = time;\n    while (t > 0) {\n        t = $bm_sub(t, thisComp.frameDuration);\n        if (simulate)\n            propSpeed = getPropWorldSpeed($bm_sub(t, overlapDuration), thisProperty);\n        else\n            propSpeed = length(velocityAtTime(t));\n        if (propSpeed < threshold) {\n            fThrough = followThroughAtTime($bm_sub(t, overlapDuration));\n            break;\n        }\n    }\n    return linear(time, t, $bm_sum(t, $bm_mul(anticipationDuration, 2)), fThrough, zeroValue);\n}\nfunction smartSmooth(axis) {\n    var startKey = nearestKey(time);\n    var endKey = startKey;\n    if (time == startKey.time)\n        return 0;\n    if (time < startKey.time && startKey.index == 1)\n        return 0;\n    if (time > startKey.time && startKey.index == numKeys)\n        return 0;\n    if (time < startKey.time)\n        startKey = key($bm_sub(startKey.index, 1));\n    if (time > startKey.time)\n        endKey = key($bm_sum(startKey.index, 1));\n    var sI = 0.66;\n    var sO = 0.33;\n    var sIV = 1;\n    var sOV = 0;\n    var sVal = startKey.value;\n    var eVal = endKey.value;\n    if ($bm_isInstanceOfArray(value)) {\n        sVal = sVal[axis];\n        eVal = eVal[axis];\n    }\n    var sTime = startKey.time;\n    var eTime = endKey.time;\n    if (isKeyTop(startKey, axis))\n        sO = slowOut;\n    else {\n        var prevKey = key($bm_sub(startKey.index, 1));\n        var pVal = prevKey.value;\n        if ($bm_isInstanceOfArray(value))\n            pVal = pVal[axis];\n        sOV = $bm_div($bm_sub(sVal, pVal), $bm_sub(eVal, pVal));\n    }\n    if (isKeyTop(endKey, axis)) {\n        sI = slowIn;\n        if (endKey.index != numKeys) {\n            var nextKey = key($bm_sum(endKey.index, 1));\n            var nVal = nextKey.value;\n            if ($bm_isInstanceOfArray(value))\n                nVal = nVal[axis];\n            if (Math.abs(nVal - eVal) < 0.01 && doFollowThrough)\n                sI = 1;\n        }\n    } else {\n        var nextKey = key($bm_sum(endKey.index, 1));\n        var nVal = nextKey.value;\n        if ($bm_isInstanceOfArray(value))\n            nVal = nVal[axis];\n        sIV = $bm_div($bm_sub(eVal, sVal), $bm_sub(nVal, sVal));\n    }\n    if (endKey.index == numKeys && doFollowThrough) {\n        sI = 1;\n    }\n    var val = value;\n    if ($bm_isInstanceOfArray(value))\n        val = val[axis];\n    return $bm_sub(bezierInterpolation(time, sTime, eTime, sVal, eVal, [\n        sO,\n        sOV,\n        sI,\n        sIV\n    ]), val);\n}\nfunction overlap() {\n    var ol = zeroValue;\n    if (isThisPosition && !hasParent)\n        return zeroValue;\n    ol = $bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisProperty), getPropWorldValue(time, thisProperty));\n    var motionRatio = $bm_div($bm_div(length(zeroValue, ol), thisLayer.width), 2);\n    if (isThisPosition) {\n        var originalDistance = length(valueAtTime(0));\n        motionRatio = $bm_div(length(zeroValue, ol), thisComp.width);\n    }\n    ol = $bm_sum(ol, getPropWorldValue(time, thisProperty));\n    ol = $bm_sum(ol, $bm_mul($bm_mul($bm_sub(getPropWorldValue($bm_sub(time, overlapDuration), thisLayer.anchorPoint), ol), motionRatio), flexibility));\n    ol = thisLayer.fromWorld(ol);\n    if (!isThisPosition)\n        ol = $bm_sub(ol, value);\n    else {\n        ol = linear(flexibility, 0, 100, $bm_div(ol, 2), 0);\n        var prevParentWorldPos = getLayerWorldPos($bm_sub(time, overlapDuration), parent);\n        ol = $bm_sum(ol, $bm_mul($bm_mul($bm_mul(thisLayer.fromWorld(prevParentWorldPos), motionRatio), flexibility), 5));\n    }\n    return ol;\n}\nvar okToGo = false;\nif (simulate && fx.enabled)\n    okToGo = true;\nelse if (numKeys > 1 && fx.enabled)\n    okToGo = true;\nif (okToGo) {\n    var smartSmoothResult = zeroValue;\n    if (doInterpolation) {\n        if ($bm_isInstanceOfArray(value)) {\n            if (value.length == 2)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1)\n                ];\n            else if (value.length == 3)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2)\n                ];\n            else if (value.length == 4)\n                smartSmoothResult = [\n                    smartSmooth(0),\n                    smartSmooth(1),\n                    smartSmooth(2),\n                    smartSmooth(3)\n                ];\n        } else {\n            smartSmoothResult = smartSmooth(0);\n        }\n    }\n    if (doAnticipation)\n        result = $bm_sum(result, anticipate());\n    result = $bm_sum(result, smartSmoothResult);\n    if (doFollowThrough)\n        result = $bm_sum(result, followThrough());\n    if (doOverlap)\n        result = $bm_sum(result, overlap());\n}\n$bm_rt = result;"},"sk":{"a":0,"k":0,"ix":4},"p":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[-168,21],"t":50,"ti":[0,0],"to":[-1.667,21.667]},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[-178,151],"t":100,"ti":[-1.667,21.667],"to":[0,0]},{"s":[-168,21],"t":150}],"ix":2},"r":{"a":1,"k":[{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[0],"t":50},{"o":{"x":0.333,"y":0},"i":{"x":0.667,"y":1},"s":[-46],"t":100},{"s":[0],"t":150}],"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]},{"ty":"tr","a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"sk":{"a":0,"k":0,"ix":4},"p":{"a":0,"k":[0,0],"ix":2},"r":{"a":0,"k":0,"ix":6},"sa":{"a":0,"k":0,"ix":5},"o":{"a":0,"k":100,"ix":7}}]}],"ind":6}],"v":"5.7.11","fr":25,"op":151,"ip":0,"assets":[]}