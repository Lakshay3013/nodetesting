{"version":3,"file":"static/js/6873.4cefb9ab.chunk.js","mappings":"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","sources":["../node_modules/@ckeditor/ckeditor5-react/src/utils/uid.ts","../node_modules/@ckeditor/ckeditor5-react/src/lifecycle/LifeCycleElementSemaphore.ts","../node_modules/@ckeditor/ckeditor5-react/src/utils/once.ts","../node_modules/@ckeditor/ckeditor5-react/src/utils/defer.ts","../node_modules/@ckeditor/ckeditor5-react/src/hooks/useIsMountedRef.ts","../node_modules/@ckeditor/ckeditor5-react/src/ckeditorcontext.tsx","../node_modules/@ckeditor/ckeditor5-react/src/ckeditor.tsx","../node_modules/@ckeditor/ckeditor5-react/src/utils/mergeRefs.ts","../node_modules/@ckeditor/ckeditor5-react/src/utils/shallowCompareArrays.ts","../node_modules/@ckeditor/ckeditor5-react/src/useMultiRootEditor.tsx"],"sourcesContent":["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * A hash table of hex numbers to avoid using toString() in uid() which is costly.\n * [ '00', '01', '02', ..., 'fe', 'ff' ]\n */\nconst HEX_NUMBERS = new Array( 256 ).fill( '' )\n\t.map( ( _, index ) => ( '0' + ( index ).toString( 16 ) ).slice( -2 ) );\n\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\nexport function uid(): string {\n\t// Let's create some positive random 32bit integers first.\n\t//\n\t// 1. Math.random() is a float between 0 and 1.\n\t// 2. 0x100000000 is 2^32 = 4294967296.\n\t// 3. >>> 0 enforces integer (in JS all numbers are floating point).\n\t//\n\t// For instance:\n\t//\t\tMath.random() * 0x100000000 = 3366450031.853859\n\t// but\n\t//\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n\tconst r1 = Math.random() * 0x100000000 >>> 0;\n\tconst r2 = Math.random() * 0x100000000 >>> 0;\n\tconst r3 = Math.random() * 0x100000000 >>> 0;\n\tconst r4 = Math.random() * 0x100000000 >>> 0;\n\n\t// Make sure that id does not start with number.\n\treturn 'e' +\n\t\tHEX_NUMBERS[ r1 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 24 & 0xFF ];\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { createDefer, type Defer } from '../utils/defer';\nimport { once } from '../utils/once';\n\n/**\n * This class is utilized to pause the initialization of an editor when another instance is already present on a specified element.\n * It is engineered to address the following issues:\n *\n *\t* Rapid changes in component properties often lead to the re-initialization of the editor, which can trigger\n *\t  the `editor-source-element-already-used` exception. This occurs because the editor is still in the process of initializing\n *\t  when the component decides to destroy it. This semaphore waits for the editor to fully initialize before destroying it, thereby\n *\t  allowing a new instance of the editor to be attached to the specified element.\n *\n *\t* Rapid mounting and unmounting in strict mode frequently results in the `editor-source-element-already-used` exception\n *\t  being thrown by the editor. This is due to React reusing the underlying DOM element during the mounting and unmounting of components\n *\t  (especially if the same component is being mounted and unmounted). Consequently, a race condition arises. The first render begins to\n *\t  attach the editor (in async mode), and shortly thereafter, it is destroyed and a new instance of the component is initialized.\n *\t  This semaphore, by utilizing a static semaphores promises map, retains information about whether the element is used by a previous\n *\t  instance of the editor and resumes execution when it is freed.\n *\n *\t* The process involves starting up many editors that are no longer needed and are immediately removed in the following rerenders.\n *\t  This can cause the editor’s initialization performance to slow down. The initialization of the editor is skipped when numerous\n *\t  rerenders occur within a short time-frame while using this semaphore. An example of this could be a situation with 4 rerenders\n *\t  occurring within a 10ms period. This semaphore will likely batch these calls, and instead of initializing 4 editors, only 2 will be\n *\t  initialized (the first and the last one).\n */\nexport class LifeCycleElementSemaphore<R> {\n\t/**\n\t * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n\t * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n\t * editor instances on an element that is already in use by another instance. The process works as follows:\n\t *\n\t * \t1. If an element is being used by an editor, then the initialization of a new editor\n\t * \t   instance is chained using the `.then()` method of the Promise.\n\t *\n\t * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n\t * \t   and the previously assigned `.then()` editor callback is executed.\n\t *\n\t *  @see {@link #lock} for more detailed information on the implementation.\n\t */\n\tprivate static readonly _semaphores = new Map<HTMLElement, Promise<void>>();\n\n\t/**\n\t * This should define async methods for initializing and destroying the editor.\n\t * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n\t *\n\t * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n\t */\n\tprivate readonly _lifecycle: LifeCycleAsyncOperators<R>;\n\n\t/**\n\t * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n\t * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n\t * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n\t * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n\t */\n\tprivate readonly _element: HTMLElement;\n\n\t/**\n\t * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n\t *\n\t * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n\t * \t  occupying the element), then it is null.\n\t *\n\t * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n\t * \t  resolved after the editor is destroyed.\n\t *\n\t * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n\t */\n\tprivate _releaseLock: Defer<void> | null = null;\n\n\t/**\n\t * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n\t * once the semaphore is released. It is utilized to store certain data that must be removed following\n\t * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n\t * or handles for additional window listeners.\n\t */\n\tprivate _value: R | null = null;\n\n\t/**\n\t * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n\t * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n\t * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n\t * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n\t */\n\tprivate _afterMountCallbacks: Array<LifeCycleAfterMountCallback<R>> = [];\n\n\t/**\n\t * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n\t * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n\t * should be destroyed.\n\t *\n\t * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n\t * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n\t * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n\t * \t  and simply release the semaphore.\n\t *\n\t *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n\t \t  the editor must be destroyed before the semaphore is released.\n\t*/\n\tprivate _state: LifeCycleState<R> = {\n\t\tdestroyedBeforeInitialization: false,\n\t\tmountingInProgress: null\n\t};\n\n\tconstructor( element: HTMLElement, lifecycle: LifeCycleAsyncOperators<R> ) {\n\t\tthis._element = element;\n\t\tthis._lifecycle = lifecycle;\n\t\tthis._lock();\n\t}\n\n\t/**\n\t * Getter for {@link #_value}.\n\t */\n\tpublic get value(): R | null {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n\t * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n\t * with a different one.\n\t */\n\tpublic unsafeSetValue( value: R ): void {\n\t\tthis._value = value;\n\n\t\tthis._afterMountCallbacks.forEach( callback => callback( value ) );\n\t\tthis._afterMountCallbacks = [];\n\t}\n\n\t/**\n\t * This registers a callback that will be triggered after the editor has been successfully mounted.\n\t *\n\t * \t* If the editor is already mounted, the callback will be executed immediately.\n\t *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n\t* \t* If the editor is never mounted, the passed callback will not be executed.\n\t* \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n\t*/\n\tpublic runAfterMount( callback: LifeCycleAfterMountCallback<R> ): void {\n\t\tconst { _value, _afterMountCallbacks } = this;\n\n\t\tif ( _value ) {\n\t\t\tcallback( _value );\n\t\t} else {\n\t\t\t_afterMountCallbacks.push( callback );\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to inform other components that the {@link #_element} will be used by the editor,\n\t * which is initialized by the {@link #_lifecycle} methods.\n\t *\n\t * \t* If an editor is already present on the provided element, the initialization of the current one\n\t * \t  will be postponed until the previous one is destroyed.\n\t *\n\t * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n\t * \t  be mounted immediately.\n\t *\n\t * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n\t * the `onReady` lifecycle method is called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tprivate _lock(): void {\n\t\tconst { _semaphores } = LifeCycleElementSemaphore;\n\t\tconst { _state, _element, _lifecycle } = this;\n\n\t\t// This promise signifies that the previous editor is still attached to the current element.\n\t\t// Upon successful resolution, it will indicate that it is safe to assume that the element has\n\t\t// no assigned editor instance and can be reinitialized.\n\t\tconst prevElementSemaphore = _semaphores.get( _element ) || Promise.resolve( null );\n\n\t\t// This is a lock that will be resolved after the `release` method is called. Due to this lock,\n\t\t// the promise will never be resolved until the editor is destroyed.\n\t\tconst releaseLock = createDefer();\n\t\tthis._releaseLock = releaseLock;\n\n\t\t// This is the initialization of the editor that occurs after the previous editor has been detached from the specified element.\n\t\t//\n\t\t// If the `release` method was called before the initialization of the current editor instance, then it will be skipped.\n\t\t// This situation occurs quite frequently when we have three or more rerenders in a row, and it doesn't make sense to initialize\n\t\t// the second editor because it will be overridden anyway by the third one.\n\t\tconst newElementSemaphore = prevElementSemaphore\n\t\t\t.then( () => {\n\t\t\t\tif ( _state.destroyedBeforeInitialization ) {\n\t\t\t\t\treturn Promise.resolve( undefined );\n\t\t\t\t}\n\n\t\t\t\t// This variable will be used later in the `release` method to determine\n\t\t\t\t// whether the editor is being destroyed prior to initialization.\n\t\t\t\t_state.mountingInProgress = _lifecycle.mount().then( mountResult => {\n\t\t\t\t\tif ( mountResult ) {\n\t\t\t\t\t\tthis.unsafeSetValue( mountResult );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn mountResult;\n\t\t\t\t} );\n\n\t\t\t\treturn _state.mountingInProgress;\n\t\t\t} )\n\t\t\t.then( async mountResult => {\n\t\t\t\t// Everything is fine, all ready callback might be fired here.\n\t\t\t\tif ( mountResult && _lifecycle.afterMount ) {\n\t\t\t\t\tawait _lifecycle.afterMount( {\n\t\t\t\t\t\telement: _element,\n\t\t\t\t\t\tmountResult\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// It will be released after destroying of editor by the {@link #_release method}.\n\t\t\t.then( () => releaseLock.promise )\n\n\t\t\t// Prevent hanging of semaphore during mount, just assume that everything is fine\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( 'Semaphore mounting error:', error );\n\t\t\t} )\n\n\t\t\t// Remove semaphore from map if released.\n\t\t\t.then( () => {\n\t\t\t\tif ( _semaphores.get( _element ) === newElementSemaphore ) {\n\t\t\t\t\t_semaphores.delete( _element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t_semaphores.set( _element, newElementSemaphore );\n\t}\n\n\t/**\n\t * Inverse of {@link #_lock} method that tries to destroy attached editor.\n\t *\n\t * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n\t * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n\t *\n\t * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n\t * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tpublic readonly release = once( () => {\n\t\tconst { _releaseLock, _state, _element, _lifecycle } = this;\n\n\t\tif ( _state.mountingInProgress ) {\n\t\t\t_state.mountingInProgress\n\t\t\t\t.then( () => _lifecycle.unmount( {\n\t\t\t\t\telement: _element,\n\n\t\t\t\t\t// Mount result might be overridden by watchdog during restart so use instance variable.\n\t\t\t\t\tmountResult: this.value!\n\t\t\t\t} ) )\n\n\t\t\t\t// Prevent hanging of semaphore during unmount, just assume that everything is fine\n\t\t\t\t.catch( error => {\n\t\t\t\t\tconsole.error( 'Semaphore unmounting error:', error );\n\t\t\t\t} )\n\n\t\t\t\t.then( _releaseLock!.resolve )\n\t\t\t\t.then( () => {\n\t\t\t\t\tthis._value = null;\n\t\t\t\t} );\n\t\t} else {\n\t\t\t_state.destroyedBeforeInitialization = true;\n\t\t\t_releaseLock!.resolve();\n\t\t}\n\t} );\n}\n\nexport type LifeCycleAfterMountCallback<R> = ( mountResult: R ) => void;\n\ntype LifeCycleState<R> = {\n\tdestroyedBeforeInitialization: boolean;\n\tmountingInProgress: Promise<R> | null;\n};\n\ntype LifeCyclePostMountAttrs<R> = {\n\telement: HTMLElement;\n\tmountResult: R;\n};\n\nexport type LifeCycleAsyncOperators<R> = {\n\tmount: () => Promise<R>;\n\tafterMount?: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void> | void;\n\tunmount: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void>;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Ensures that passed function will be executed only once.\n */\nexport function once<A extends Array<any>, R = void>( fn: ( ...args: A ) => R ): ( ...args: A ) => R {\n\tlet lastResult: { current: R } | null = null;\n\n\treturn ( ...args: A ): R => {\n\t\tif ( !lastResult ) {\n\t\t\tlastResult = {\n\t\t\t\tcurrent: fn( ...args )\n\t\t\t};\n\t\t}\n\n\t\treturn lastResult.current;\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nexport type Defer<E> = {\n\tpromise: Promise<E>;\n\tresolve: ( value: E ) => void;\n};\n\n/**\n * This function generates a promise that can be resolved by invoking the returned `resolve` method.\n * It proves to be beneficial in the creation of various types of locks and semaphores.\n */\nexport function createDefer<E = void>(): Defer<E> {\n\tconst deferred: Defer<E> = {\n\t\tresolve: null as any,\n\t\tpromise: null as any\n\t};\n\n\tdeferred.promise = new Promise<E>( resolve => {\n\t\tdeferred.resolve = resolve;\n\t} );\n\n\treturn deferred;\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useEffect, useRef, type MutableRefObject } from 'react';\n\n/**\n * Custom hook that returns a mutable ref object indicating whether the component is mounted or not.\n *\n * @returns The mutable ref object.\n */\nexport const useIsMountedRef = (): MutableRefObject<boolean> => {\n\tconst mountedRef = useRef<boolean>( false );\n\n\tuseEffect( () => {\n\t\tmountedRef.current = true;\n\n\t\treturn () => {\n\t\t\tmountedRef.current = false;\n\t\t};\n\t}, [] );\n\n\treturn mountedRef;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, {\n\tuseRef, useContext, useState, useEffect,\n\ttype ReactNode, type ReactElement\n} from 'react';\n\nimport { useIsMountedRef } from './hooks/useIsMountedRef';\nimport { uid } from './utils/uid';\n\nimport type {\n\tContextWatchdog,\n\tWatchdogConfig,\n\tContext,\n\tContextConfig\n} from 'ckeditor5';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdogValue | null>( null );\n\n/**\n * Custom hook that returns the CKEditor Watchdog context value.\n */\nexport const useCKEditorWatchdogContext = (): ContextWatchdogValue | null =>\n\tuseContext( ContextWatchdogContext );\n\n/**\n * A React component that provides a context for CKEditor.\n */\nconst CKEditorContext = <TContext extends Context = Context>( props: Props<TContext> ): ReactElement | null => {\n\tconst {\n\t\tid, context, watchdogConfig,\n\t\tchildren, config, onReady,\n\t\tcontextWatchdog: ContextWatchdogConstructor,\n\t\tisLayoutReady = true,\n\t\tonError = ( error, details ) => console.error( error, details )\n\t} = props;\n\n\tconst isMountedRef = useIsMountedRef();\n\tconst prevWatchdogInitializationIDRef = useRef<string | null>( null );\n\n\t// The currentContextWatchdog state is set to 'initializing' because it is checked later in the CKEditor component\n\t// which is waiting for the full initialization of the context watchdog.\n\tconst [ currentContextWatchdog, setCurrentContextWatchdog ] = useState<ContextWatchdogValue>( {\n\t\tstatus: 'initializing'\n\t} );\n\n\tuseEffect( () => {\n\t\tif ( isLayoutReady ) {\n\t\t\tinitializeContextWatchdog();\n\t\t} else {\n\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\tstatus: 'initializing'\n\t\t\t} );\n\t\t}\n\t}, [ id, isLayoutReady ] );\n\n\tuseEffect( () => () => {\n\t\tif ( currentContextWatchdog.status === 'initialized' ) {\n\t\t\tcurrentContextWatchdog.watchdog.destroy();\n\t\t}\n\t}, [ currentContextWatchdog ] );\n\n\t/**\n\t * Regenerates the initialization ID by generating a random ID and updating the previous watchdog initialization ID.\n\t * This is necessary to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t * This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t *\n\t * @returns The regenerated initialization ID.\n\t */\n\tfunction regenerateInitializationID() {\n\t\tprevWatchdogInitializationIDRef.current = uid();\n\n\t\treturn prevWatchdogInitializationIDRef.current;\n\t}\n\n\t/**\n\t * Checks if the state can be updated based on the provided initialization ID.\n\t *\n\t * @param initializationID The initialization ID to compare with the previous one.\n\t * @returns A boolean indicating whether the state can be updated.\n\t */\n\tfunction canUpdateState( initializationID: string ) {\n\t\treturn prevWatchdogInitializationIDRef.current === initializationID && isMountedRef.current;\n\t}\n\n\t/**\n\t * Initializes the context watchdog.\n\t *\n\t * @returns Watchdog instance.\n\t */\n\tfunction initializeContextWatchdog() {\n\t\t// The prevWatchdogInitializationID variable is used to keep track of the previous initialization ID.\n\t\t// It is used to ensure that the state update is performed only if the current initialization ID matches the previous one.\n\t\t// This helps to avoid race conditions and ensures that the correct context watchdog is associated with the component.\n\t\tconst watchdogInitializationID = regenerateInitializationID();\n\t\tconst contextWatchdog = new ContextWatchdogConstructor( context!, watchdogConfig );\n\n\t\t// Handle error event from context watchdog.\n\t\tcontextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonError( errorEvent.error, {\n\t\t\t\t\tphase: 'runtime',\n\t\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\n\t\t// Handle state change event from context watchdog.\n\t\tcontextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( onReady && contextWatchdog.state === 'ready' && canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\tonReady(\n\t\t\t\t\tcontextWatchdog.context! as TContext,\n\t\t\t\t\tcontextWatchdog\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t\t// Create the context watchdog and initialize it with the provided config.\n\t\tcontextWatchdog\n\t\t\t.create( config )\n\t\t\t.then( () => {\n\t\t\t\t// Check if the state update is still valid and update the current context watchdog.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'initialized',\n\t\t\t\t\t\twatchdog: contextWatchdog\n\t\t\t\t\t} );\n\t\t\t\t} else {\n\t\t\t\t\t// Destroy the context watchdog if the state update is no longer valid.\n\t\t\t\t\tcontextWatchdog.destroy();\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\t// Update the current context watchdog with the error status.\n\t\t\t\tif ( canUpdateState( watchdogInitializationID ) ) {\n\t\t\t\t\t// Handle error during context watchdog initialization.\n\t\t\t\t\tonError( error, {\n\t\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\t\twillContextRestart: false\n\t\t\t\t\t} );\n\n\t\t\t\t\tsetCurrentContextWatchdog( {\n\t\t\t\t\t\tstatus: 'error',\n\t\t\t\t\t\terror\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\n\t\treturn contextWatchdog;\n\t}\n\n\treturn (\n\t\t<ContextWatchdogContext.Provider value={currentContextWatchdog}>\n\t\t\t{children}\n\t\t</ContextWatchdogContext.Provider>\n\t);\n};\n\n/**\n * Checks if the given object is of type ContextWatchdogValue.\n *\n * @param obj The object to be checked.\n * @returns True if the object is of type ContextWatchdogValue, false otherwise.\n */\nexport const isContextWatchdogValue = ( obj: any ): obj is ContextWatchdogValue =>\n\t!!obj && typeof obj === 'object' && 'status' in obj && [ 'initializing', 'initialized', 'error' ].includes( obj.status );\n\n/**\n * Checks if the provided object is a context watchdog value with the specified status.\n */\nexport const isContextWatchdogValueWithStatus = <S extends ContextWatchdogValueStatus>( status: S ) =>\n\t( obj: any ): obj is ExtractContextWatchdogValueByStatus<S> =>\n\t\tisContextWatchdogValue( obj ) && obj.status === status;\n\n/**\n * Checks if the context watchdog is currently initializing.\n */\nexport const isContextWatchdogInitializing = isContextWatchdogValueWithStatus( 'initializing' );\n\n/**\n * Checks if the provided object is a fully initialized context watchdog value. It prevents race conditions between\n * watchdog state that is not fully synchronized with the context state. For example, the watchdog state can be 'destroyed'\n * while the context is still being initialized because context setState is pending.\n */\nexport const isContextWatchdogReadyToUse = ( obj: any ): obj is ExtractContextWatchdogValueByStatus<'initialized'> => (\n\tisContextWatchdogValueWithStatus( 'initialized' )( obj ) &&\n\tobj.watchdog.state === 'ready'\n);\n\n/**\n * Represents the value of the ContextWatchdog in the CKEditor context.\n */\nexport type ContextWatchdogValue =\n\t| {\n\t\tstatus: 'initializing';\n\t}\n\t| {\n\t\tstatus: 'initialized';\n\t\twatchdog: ContextWatchdog;\n\t}\n\t| {\n\t\tstatus: 'error';\n\t\terror: ErrorDetails;\n\t};\n\nexport type ContextWatchdogValueStatus = ContextWatchdogValue[ 'status' ];\n\n/**\n * Extracts a specific type of `ContextWatchdogValue` based on its status.\n */\nexport type ExtractContextWatchdogValueByStatus<S extends ContextWatchdogValueStatus> = Extract<\n\tContextWatchdogValue,\n\t{ status: S }\n>;\n\n/**\n * Props for the CKEditorContext component.\n */\nexport type Props<TContext extends Context> = {\n\tid?: string;\n\tisLayoutReady?: boolean;\n\tcontext?: { create( ...args: any ): Promise<TContext> };\n\tcontextWatchdog: typeof ContextWatchdog<TContext>;\n\twatchdogConfig?: WatchdogConfig;\n\tconfig?: ContextConfig;\n\tonReady?: ( context: TContext, watchdog: ContextWatchdog<TContext> ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tchildren?: ReactNode;\n};\n\ntype ErrorDetails = {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n};\n\nexport default CKEditorContext;\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window */\n\nimport React from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport type {\n\tEventInfo,\n\tEditor,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tEditorWatchdog,\n\tContextWatchdog,\n\tWatchdogConfig,\n\tEditorCreatorFunction\n} from 'ckeditor5';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\n\nimport { uid } from './utils/uid';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\nimport {\n\tContextWatchdogContext,\n\tisContextWatchdogInitializing,\n\tisContextWatchdogReadyToUse\n} from './ckeditorcontext';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>> {\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * Unlocks element in editor semaphore after destroy editor instance.\n\t */\n\tprivate editorSemaphore: LifeCycleElementSemaphore<EditorSemaphoreMountResult<TEditor>> | null = null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tthis._checkVersion();\n\t}\n\n\t/**\n\t * Checks if the CKEditor version used in the application is compatible with the component.\n\t */\n\tprivate _checkVersion(): void {\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( !CKEDITOR_VERSION ) {\n\t\t\treturn console.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\n\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\tif ( major >= 42 || CKEDITOR_VERSION.startsWith( '0.0.0' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.' );\n\t}\n\n\tprivate get _semaphoreValue(): EditorSemaphoreMountResult<TEditor> | null {\n\t\tconst { editorSemaphore } = this;\n\n\t\treturn editorSemaphore ? editorSemaphore.value : null;\n\t}\n\n\t/**\n\t * An watchdog instance.\n\t */\n\tpublic get watchdog(): EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.watchdog : null;\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.instance : null;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tconst { props, editorSemaphore } = this;\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( editorSemaphore ) {\n\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\tif ( this._shouldUpdateEditorData( props, nextProps, instance ) ) {\n\t\t\t\t\tinstance.data.set( nextProps.data! );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( 'disabled' in nextProps ) {\n\t\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\t\tif ( nextProps.disabled ) {\n\t\t\t\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override componentDidMount(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override componentDidUpdate(): void {\n\t\tif ( !isContextWatchdogInitializing( this.context ) ) {\n\t\t\tthis._initLifeCycleSemaphore();\n\t\t}\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override componentWillUnmount(): void {\n\t\tthis._unlockLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Async destroy attached editor and unlock element semaphore.\n\t */\n\tprivate _unlockLifeCycleSemaphore() {\n\t\tif ( this.editorSemaphore ) {\n\t\t\tthis.editorSemaphore.release();\n\t\t\tthis.editorSemaphore = null;\n\t\t}\n\t}\n\n\t/**\n\t * Unlocks previous editor semaphore and creates new one..\n\t */\n\tprivate _initLifeCycleSemaphore() {\n\t\tthis._unlockLifeCycleSemaphore();\n\t\tthis.editorSemaphore = new LifeCycleElementSemaphore( this.domContainer.current!, {\n\t\t\tmount: async () => this._initializeEditor(),\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = this.props;\n\n\t\t\t\tif ( onReady && this.domContainer.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this._destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<EditorSemaphoreMountResult<TEditor>> {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tconst instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as TEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\t// There is small delay where React did not update the context yet but watchdog is already destroyed.\n\t\t\t// However editor should be created again in such case, after receiving new context.\n\t\t\tif ( isContextWatchdogReadyToUse( this.context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( this.context.watchdog );\n\t\t\t}\n\n\t\t\treturn new this.props.editor.EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<TEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( el, config ) => {\n\t\t\tconst { editorSemaphore } = this;\n\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorSemaphore?.value?.instance ) {\n\t\t\t\tonAfterDestroy( editorSemaphore.value.instance );\n\t\t\t}\n\n\t\t\tconst instance = await this._createEditor( el as any, config );\n\n\t\t\t// The editor semaphore can be unavailable at this stage. There is a small chance that the component\n\t\t\t// was destroyed while watchdog was initializing new instance of editor. In such case, we should not\n\t\t\t// call any callbacks or set any values to the semaphore.\n\t\t\tif ( editorSemaphore && totalRestartsRef.current > 0 ) {\n\t\t\t\teditorSemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( watchdog!.editor as TEditor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( this.domContainer.current!, this._getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = this.props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\treturn this.props.editor.create( element as HTMLElement, config )\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor( initializeResult: EditorSemaphoreMountResult<Editor> ): Promise<void> {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param prevProps Previous react's properties.\n\t * @param nextProps React's properties.\n\t * @param editor Current editor instance.\n\t */\n\tprivate _shouldUpdateEditorData( prevProps: Readonly<Props<TEditor>>, nextProps: Readonly<Props<TEditor>>, editor: TEditor ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( prevProps.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( editor.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n\n\t// Properties definition.\n\tpublic static propTypes = {\n\t\teditor: PropTypes.func.isRequired as unknown as Validator<{ create( ...args: any ): Promise<any> }>,\n\t\tdata: PropTypes.string,\n\t\tconfig: PropTypes.object,\n\t\tdisableWatchdog: PropTypes.bool,\n\t\twatchdogConfig: PropTypes.object,\n\t\tonChange: PropTypes.func,\n\t\tonReady: PropTypes.func,\n\t\tonFocus: PropTypes.func,\n\t\tonBlur: PropTypes.func,\n\t\tonError: PropTypes.func,\n\t\tdisabled: PropTypes.bool,\n\t\tid: PropTypes.any\n\t};\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\nexport interface Props<TEditor extends Editor> extends InferProps<typeof CKEditor.propTypes> {\n\teditor: {\n\t\tcreate( ...args: any ): Promise<TEditor>;\n\t\tEditorWatchdog: typeof EditorWatchdog;\n\t\tContextWatchdog: typeof ContextWatchdog;\n\t};\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonAfterDestroy?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: EditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: EditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport type { MutableRefObject } from 'react';\n\ntype CallbackRef<T> = ( element: T ) => void;\n\ntype ReactRef<T> = CallbackRef<T | null> | MutableRefObject<T | null> | null;\n\n/**\n * Combine multiple react refs into one.\n */\nexport function mergeRefs<T>( ...refs: Array<ReactRef<T>> ): CallbackRef<T> {\n\treturn value => {\n\t\trefs.forEach( ref => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref != null ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t};\n}\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Shallow comparison of two arrays.\n */\nexport const shallowCompareArrays = <T>(\n\ta: Readonly<Array<T>>,\n\tb: Readonly<Array<T>>\n): boolean => {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tif ( !a || !b ) {\n\t\treturn false;\n\t}\n\n\tfor ( let i = 0; i < a.length; ++i ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n","/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, {\n\tforwardRef, useState, useEffect, useRef, useContext, useCallback, memo,\n\ttype Dispatch, type SetStateAction, type RefObject\n} from 'react';\n\nimport type {\n\tInlineEditableUIView,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tWriter,\n\tRootElement,\n\tWatchdogConfig,\n\tAddRootEvent,\n\tDetachRootEvent,\n\tMultiRootEditor,\n\tEventInfo\n} from 'ckeditor5';\n\nimport { ContextWatchdogContext, isContextWatchdogReadyToUse } from './ckeditorcontext';\nimport { EditorWatchdogAdapter } from './ckeditor';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\n\nimport { useLifeCycleSemaphoreSyncRef, type LifeCycleSemaphoreSyncRefResult } from './lifecycle/useLifeCycleSemaphoreSyncRef';\nimport { mergeRefs } from './utils/mergeRefs';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\nimport { overwriteObject } from './utils/overwriteObject';\nimport { useRefSafeCallback } from './hooks/useRefSafeCallback';\nimport { uniq } from './utils/uniq';\nimport { overwriteArray } from './utils/overwriteArray';\nimport { useInstantEditorEffect } from './hooks/useInstantEditorEffect';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst semaphoreElementRef = useRef<HTMLElement>( props.semaphoreElement || null );\n\tconst semaphore = useLifeCycleSemaphoreSyncRef<LifeCycleMountResult>();\n\n\tconst editorRefs: LifeCycleSemaphoreRefs<MultiRootEditor> = {\n\t\twatchdog: semaphore.createAttributeRef( 'watchdog' ),\n\t\tinstance: semaphore.createAttributeRef( 'instance' )\n\t};\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// List of editor root elements.\n\tconst [ roots, setRoots ] = useState<Array<string>>( () => Object.keys( props.data ) );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( { ...props.data } );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( { ...props.rootsAttributes } );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\t/**\n\t * It's possible to unmount `useMultiRootEditor` with created editor and `elements` that are not attached to any React node.\n\t * It means that CKEditor will try to destroy editor and all it's roots in destructor. It will throw an error because\n\t * `editables` are not attached to any React node and their elements references are null. To prevent this error we need to\n\t * force assign `editables` to fake elements before destroying editor.\n\t *\n\t * See: https://github.com/ckeditor/ckeditor5/issues/16561\n\t */\n\tconst forceAssignFakeEditableElements = () => {\n\t\tconst editor = editorRefs.instance.current;\n\n\t\tif ( !editor ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst initializeEditableWithFakeElement = ( editable: InlineEditableUIView ) => {\n\t\t\tif ( editable.name && !editor.editing.view.getDomRoot( editable.name ) ) {\n\t\t\t\teditor.editing.view.attachDomRoot( document.createElement( 'div' ), editable.name );\n\t\t\t}\n\t\t};\n\n\t\tObject\n\t\t\t.values( editor.ui.view.editables )\n\t\t\t.forEach( initializeEditableWithFakeElement );\n\t};\n\n\tuseEffect( () => {\n\t\tconst semaphoreElement = semaphoreElementRef.current;\n\n\t\t// Check if parent context is ready (only if it is provided).\n\t\tif ( context && !isContextWatchdogReadyToUse( context ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if hook internal state or attributes are not ready yet.\n\t\tif ( !semaphoreElement || props.isLayoutReady === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsemaphore.replace( () => new LifeCycleElementSemaphore( semaphoreElement, {\n\t\t\tmount: _initializeEditor,\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = props;\n\n\t\t\t\tif ( onReady && semaphoreElementRef.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait _destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} ) );\n\n\t\treturn () => {\n\t\t\tforceAssignFakeEditableElements();\n\t\t\tsemaphore.release( false );\n\t\t};\n\t}, [ props.id, props.isLayoutReady, context?.status ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = useRefSafeCallback( ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: RootElement;\n\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as RootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as RootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else -- @preserve */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t} );\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = useRefSafeCallback( ( editor: MultiRootEditor, _evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetRoots( prevRoots => uniq( [ ...prevRoots, root.rootName ] ) );\n\t} );\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = useRefSafeCallback( ( _editor: MultiRootEditor, _evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\tsetRoots( prevRoots => prevRoots.filter( root => root !== rootName ) );\n\t} );\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = useRefSafeCallback( (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\toverwriteObject( { ...props.rootsAttributes }, attributes );\n\t\toverwriteObject( { ...props.data }, data );\n\t\toverwriteArray( Object.keys( props.data ), roots );\n\n\t\treturn props.editor.create( initialData, config )\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tconst editorData = editor.getFullData();\n\n\t\t\t\t// Rerender will be called anyway.\n\t\t\t\toverwriteObject( { ...editorData }, data );\n\t\t\t\toverwriteObject( { ...editor.getRootsAttributes() }, attributes );\n\t\t\t\toverwriteArray( Object.keys( editorData ), roots );\n\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t} );\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = ( initializeResult: EditorSemaphoreMountResult<MultiRootEditor> ): Promise<void> => {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next -- @preserve */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<LifeCycleMountResult> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tconst instance = await _createEditor( props.data as any, _getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as MultiRootEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( isContextWatchdogReadyToUse( context ) ) {\n\t\t\t\treturn new EditorWatchdogAdapter( context.watchdog );\n\t\t\t}\n\n\t\t\treturn new props.editor.EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<MultiRootEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( data, config ) => {\n\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current ) {\n\t\t\t\tonAfterDestroy( editorRefs.instance.current );\n\t\t\t}\n\n\t\t\tconst instance = await _createEditor( data as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\tsemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\t\tprops.onReady( watchdog!.editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t\tthrow error;\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t};\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetData( newData );\n\t\t\t} );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetAttributes( newAttributes );\n\t\t\t} );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\tconst toolbarElement = (\n\t\t<EditorToolbarWrapper\n\t\t\tref={ semaphoreElementRef }\n\t\t\teditor={editorRefs.instance.current}\n\t\t/>\n\t);\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\tif ( props.disabled ) {\n\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t} else {\n\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tconsole.error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = instance.getFullData();\n\t\t\tconst editorAttributes = instance.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff(\n\t\t\t\teditorData,\n\t\t\t\tdata || /* istanbul ignore next -- @preserve: It should never happen, data should be always filled. */ {}\n\t\t\t);\n\n\t\t\tconst hasModifiedData = dataKeys.some( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.addRoot( rootName, {\n\t\t\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\t\t\tattributes: attributes?.[ rootName ] ||\n\t\t\t\t\t\t/* istanbul ignore next -- @preserve: attributes should be in sync with root keys */ {},\n\t\t\t\t\t\tisUndoable: true\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.detachRoot( rootName, true );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _updateEditorData = () => {\n\t\t\t\t// If any of the roots content has changed, set the editor data.\n\t\t\t\t// Unfortunately, we cannot set the editor data just for one root,\n\t\t\t\t// so we need to overwrite all roots (`nextProps.data` is an\n\t\t\t\t// object with data for each root).\n\t\t\t\tinstance.data.set( data, { suppressErrorInCollaboration: true } as any );\n\t\t\t};\n\n\t\t\tconst _updateEditorAttributes = ( writer: Writer, roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\t\t\tinstance.registerRootAttribute( attr );\n\t\t\t\t\t} );\n\n\t\t\t\t\twriter.clearAttributes( instance.model.document.getRoot( rootName )! );\n\t\t\t\t\twriter.setAttributes( attributes![ rootName ], instance.model.document.getRoot( rootName )! );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\t// React struggles with rerendering during `instance.model.change` callbacks.\n\t\t\tsetTimeout( () => {\n\t\t\t\tinstance.model.change( writer => {\n\t\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\t\tif ( hasModifiedData ) {\n\t\t\t\t\t\t_updateEditorData();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst editableElements = roots.map(\n\t\trootName => (\n\t\t\t<EditorEditable\n\t\t\t\tkey={rootName}\n\t\t\t\tid={rootName}\n\t\t\t\trootName={rootName}\n\t\t\t\tsemaphore={semaphore}\n\t\t\t/>\n\t\t)\n\t);\n\n\treturn {\n\t\teditor: editorRefs.instance.current,\n\t\teditableElements,\n\t\ttoolbarElement,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nexport const EditorEditable = memo( forwardRef( ( { id, semaphore, rootName }: {\n\tid: string;\n\trootName: string;\n\tsemaphore: LifeCycleSemaphoreSyncRefResult<LifeCycleMountResult>;\n}, ref ) => {\n\tconst innerRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tlet editable: InlineEditableUIView | null;\n\t\tlet editor: MultiRootEditor | null;\n\n\t\tsemaphore.runAfterMount( ( { instance } ) => {\n\t\t\tif ( !innerRef.current ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\teditor = instance;\n\n\t\t\tconst { ui, model } = editor;\n\t\t\tconst root = model.document.getRoot( rootName );\n\n\t\t\tif ( root && editor.ui.getEditableElement( rootName ) ) {\n\t\t\t\teditor.detachEditable( root );\n\t\t\t}\n\n\t\t\teditable = ui.view.createEditable( rootName, innerRef.current );\n\t\t\tui.addEditable( editable );\n\n\t\t\tinstance.editing.view.forceRender();\n\t\t} );\n\n\t\treturn () => {\n\t\t\tif ( editor && editor.state !== 'destroyed' && innerRef.current ) {\n\t\t\t\tconst root = editor.model.document.getRoot( rootName );\n\n\t\t\t\t/* istanbul ignore else -- @preserve */\n\t\t\t\tif ( root ) {\n\t\t\t\t\teditor.detachEditable( root );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, [ semaphore.revision ] );\n\n\treturn (\n\t\t<div\n\t\t\tkey={semaphore.revision}\n\t\t\tid={id}\n\t\t\tref={ mergeRefs( ref, innerRef ) }\n\t\t/>\n\t);\n} ) );\n\nEditorEditable.displayName = 'EditorEditable';\n\nexport const EditorToolbarWrapper = forwardRef( ( { editor }: any, ref ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\ttoolbarContainer.appendChild( element! );\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer.contains( element ) ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={mergeRefs( toolbarRef, ref )}></div>;\n} );\n\nEditorToolbarWrapper.displayName = 'EditorToolbarWrapper';\n\nexport default useMultiRootEditor;\n\ntype LifeCycleMountResult = EditorSemaphoreMountResult<MultiRootEditor>;\n\ntype LifeCycleSemaphoreRefs<TEditor extends MultiRootEditor> = {\n\t[ K in keyof EditorSemaphoreMountResult<TEditor> ]: RefObject<EditorSemaphoreMountResult<TEditor>[ K ]>\n};\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tid?: any;\n\tsemaphoreElement?: HTMLElement;\n\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonAfterDestroy?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n"],"names":["HEX_NUMBERS","Array","fill","map","_","index","toString","slice","uid","r1","Math","random","r2","r3","r4","_LifeCycleElementSemaphore","constructor","element","lifecycle","__publicField","destroyedBeforeInitialization","mountingInProgress","fn","lastResult","current","arguments","once","_releaseLock","_state","_element","_lifecycle","this","then","unmount","mountResult","value","catch","error","console","resolve","_value","_lock","unsafeSetValue","_afterMountCallbacks","forEach","callback","runAfterMount","push","_semaphores","prevElementSemaphore","get","Promise","releaseLock","deferred","promise","createDefer","newElementSemaphore","mount","async","afterMount","delete","set","Map","LifeCycleElementSemaphore","ContextWatchdogContext","React","CKEditorContext","props","id","context","watchdogConfig","children","config","onReady","contextWatchdog","ContextWatchdogConstructor","isLayoutReady","onError","details","isMountedRef","useIsMountedRef","mountedRef","useRef","useEffect","prevWatchdogInitializationIDRef","currentContextWatchdog","setCurrentContextWatchdog","useState","status","canUpdateState","initializationID","watchdogInitializationID","on","errorEvent","phase","willContextRestart","causesRestart","state","create","watchdog","destroy","initializeContextWatchdog","Provider","isContextWatchdogValueWithStatus","obj","includes","isContextWatchdogValue","isContextWatchdogInitializing","isContextWatchdogReadyToUse","REACT_INTEGRATION_READ_ONLY_LOCK_ID$1","CKEditor","super","_checkVersion","CKEDITOR_VERSION","window","warn","major","split","Number","startsWith","_semaphoreValue","editorSemaphore","editor","instance","shouldComponentUpdate","nextProps","disableWatchdog","_ref","_shouldUpdateEditorData","data","_ref2","disabled","enableReadOnlyMode","disableReadOnlyMode","componentDidMount","_initLifeCycleSemaphore","componentDidUpdate","componentWillUnmount","_unlockLifeCycleSemaphore","release","domContainer","_initializeEditor","_ref3","_ref4","onAfterDestroy","_destroyEditor","innerHTML","render","ref","_createEditor","_getConfig","EditorWatchdogAdapter","EditorWatchdog","totalRestartsRef","setCreator","el","_a","setTimeout","_ref5","willEditorRestart","modelDocument","model","document","viewDocument","editing","view","event","onChange","onFocus","onBlur","initializeResult","reject","e","prevProps","initialData","PropTypes","isRequired","_contextWatchdog","_id","creator","_creator","sourceElementOrData","add","type","_2","_ref6","itemId","remove","getItem","mergeRefs","_len","length","refs","_key","EditorEditable","memo","forwardRef","_ref12","semaphore","rootName","innerRef","editable","_ref13","ui","root","getRoot","getEditableElement","detachEditable","createEditable","addEditable","forceRender","revision","key","displayName","EditorToolbarWrapper","_ref14","toolbarRef","toolbarContainer","toolbar","appendChild","contains","removeChild"],"sourceRoot":""}